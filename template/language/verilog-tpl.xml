<?xml version="1.0"?>
<Templates encode="utf8escenc">


<Template Name="***&#x53EF;&#x7EFC;&#x5408;&#x8BED;&#x6CD5;***" Description="" Comments="0" Strings="0"/><Template Name="module" Description="" Comments="0" Strings="0">//------------------------------------------------------------------------------------------------- &#xD;
//  -- &#x7248;&#x6743;&#x6240;&#x6709;&#x8005;   : &#x4E2D;&#x56FD;&#x5927;&#x6052;&#xFF08;&#x96C6;&#x56E2;&#xFF09;&#x6709;&#x9650;&#x516C;&#x53F8;&#x5317;&#x4EAC;&#x56FE;&#x50CF;&#x89C6;&#x89C9;&#x6280;&#x672F;&#x5206;&#x516C;&#x53F8;, 2010 -2015. &#xD;
//  -- &#x4FDD;&#x5BC6;&#x7EA7;&#x522B;     &#xFF1A;&#x7EDD;&#x5BC6;. &#xD;
//  -- &#x90E8;&#x95E8;         : &#x786C;&#x4EF6;&#x90E8;&#xFF0C;FPGA&#x5DE5;&#x4F5C;&#x7EC4; &#xD;
//  -- &#x6A21;&#x5757;&#x540D;       : [FILE_NAME] &#xD;
//  -- &#x8BBE;&#x8BA1;&#x8005;       : &#x90A2;&#x6D77;&#x6D9B; &#xD;
//------------------------------------------------------------------------------------------------- &#xD;
// &#xD;
//  -- &#x7248;&#x672C;&#x8BB0;&#x5F55; : &#xD;
// &#xD;
//  -- &#x4F5C;&#x8005;         :| &#x7248;&#x672C;&#x53F7;	:| &#x4FEE;&#x6539;&#x65E5;&#x671F;				:|  &#x4FEE;&#x6539;&#x8BF4;&#x660E; &#xD;
//------------------------------------------------------------------------------------------------- &#xD;
//  -- &#x90A2;&#x6D77;&#x6D9B;       :| V1.0		:| [DATE_USER]yyyy/MM/dd[DATE_USER_END] [TIME_USER]HH':'mm':'ss[TIME_USER_END]	:|  &#x521D;&#x59CB;&#x7248;&#x672C; &#xD;
//------------------------------------------------------------------------------------------------- &#xD;
// &#xD;
//  -- &#x6A21;&#x5757;&#x63CF;&#x8FF0;     :  &#xD;
//              1)  :  &#xD;
// &#xD;
//              2)  :  &#xD;
// &#xD;
//              3)  :  &#xD;
// &#xD;
//------------------------------------------------------------------------------------------------- &#xD;
//`include			"[FILE_NAME]_def.v" &#xD;
//&#x4EFF;&#x771F;&#x5355;&#x4F4D;/&#x7CBE;&#x5EA6; `timescale 1ns/1ps &#xD;
//-------------------------------------------------------------------------------------------------  &#xD;
module [FILE_NAME] # (&#xD;
 	parameter			REG_WD			= 32	,	//&#x5BC4;&#x5B58;&#x5668;&#x4F4D;&#x5BBD;&#xD;
 	parameter			TIME_INTERVAL	= 3600000	//&#x4E2D;&#x65AD;&#x95F4;&#x9694;&#xD;
 	)&#xD;
 	(&#xD;
 	//&#x8F93;&#x5165;&#x4FE1;&#x53F7;&#xD;
 	input					clk					,	//&#x8F93;&#x5165;&#x65F6;&#x949F;&#xD;
 	input					reset				,	//&#x590D;&#x4F4D;&#x4FE1;&#x53F7;&#xD;
 	);&#xD;
&#xD;
 	//	ref paramters&#xD;
&#xD;
&#xD;
   	//	ref functions&#xD;
&#xD;
&#xD;
   	//	ref signals&#xD;
&#xD;
&#xD;
     	//	ref ARCHITECTURE&#xD;
&#xD;
  	//  ===============================================================================================&#xD;
 	//	ref ***create edge***&#xD;
 	//  ===============================================================================================&#xD;
 	//  -------------------------------------------------------------------------------------&#xD;
 	//	fval edge&#xD;
 	//  -------------------------------------------------------------------------------------&#xD;
   	//  ===============================================================================================&#xD;
 	//	ref ***output***&#xD;
 	//  ===============================================================================================&#xD;
   &#xD;
endmodule&#xD;
 </Template><Template Name="always" Description="" Comments="0" Strings="0">always @ (posedge [+clk+]) begin&#xD;
	if(^) begin&#xD;
		&#xD;
	end&#xD;
	else begin&#xD;
		&#xD;
	end&#xD;
end</Template><Template Name="alwaysc" Description="" Comments="0" Strings="0">//	-------------------------------------------------------------------------------------&#xD;
//	Conbinatial Logic&#xD;
//	-------------------------------------------------------------------------------------&#xD;
always @ ( * ) begin&#xD;
	if() begin&#xD;
		reg1	= 1'b1;&#xD;
	end&#xD;
	else begin&#xD;
		reg1	= 1'b0;&#xD;
	end&#xD;
end</Template><Template Name="add" Description="" Comments="0" Strings="0">[+sig+]	&lt;= [+sig+] + 1'b1;</Template><Template Name="sub" Description="" Comments="0" Strings="0">[+sig+]	&lt;= [+sig+] - 1'b1;</Template><Template Name="if" Description="" Comments="0" Strings="0">if([+expr+]) begin&#xD;
	^&#xD;
end</Template>

<Template Name="else" Description="" Comments="0" Strings="0">else begin&#xD;
	^&#xD;
end</Template>

<Template Name="else if" Description="" Comments="0" Strings="0">else if([+expr+]) begin&#xD;
	^&#xD;
end</Template><Template Name="begin" Description="" Comments="0" Strings="0">begin&#xD;
	&#xD;
end</Template>



<Template Name="generate" Description="" Comments="0" Strings="0">genvar	[+i+];&#xD;
generate&#xD;
	^&#xD;
endgenerate</Template>



<Template Name="for" Description="" Comments="0" Strings="0">for([+i+]=0;[+i+]&lt;[+limit+];[+i+]=[+i+]+1) begin&#xD;
	^&#xD;
end&#xD;
</Template><Template Name="case" Description="" Comments="0" Strings="0">case(^)&#xD;
case1	: begin&#xD;
	&#xD;
end&#xD;
case2	: begin&#xD;
	&#xD;
end&#xD;
default	: begin&#xD;
	&#xD;
end&#xD;
endcase&#xD;
</Template>



<Template Name="function" Description="" Comments="0" Strings="0">function [[+upper+]:[+lower+]] [+output_name+];&#xD;
	input [+input_name+];&#xD;
	begin&#xD;
		^&#xD;
	end&#xD;
endfunction&#xD;
</Template>



<Template Name="joint" Description="" Comments="0" Strings="0">{GREY_OFFSET_WIDTH{1'b0}} {1'b1,{(SHORT_REG_WD-GREY_OFFSET_WIDTH){1'b0}}} {{{{16'b0},wv_height_lane[roi_cnt]}},iv_pixel_format};</Template><Template Name="init" Description="" Comments="0" Strings="0">&lt;= [+1+]'b0;</Template><Template Name="***&#x4EFF;&#x771F;&#x8BED;&#x6CD5;***" Description="" Comments="0" Strings="0"/><Template Name="testbench" Description="" Comments="0" Strings="0">//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x7248;&#x6743;&#x6240;&#x6709;&#x8005;   : &#x4E2D;&#x56FD;&#x5927;&#x6052;&#xFF08;&#x96C6;&#x56E2;&#xFF09;&#x6709;&#x9650;&#x516C;&#x53F8;&#x5317;&#x4EAC;&#x56FE;&#x50CF;&#x89C6;&#x89C9;&#x6280;&#x672F;&#x5206;&#x516C;&#x53F8;, 2010 -2015.&#xD;
//  -- &#x4FDD;&#x5BC6;&#x7EA7;&#x522B;     &#xFF1A;&#x7EDD;&#x5BC6;.&#xD;
//  -- &#x90E8;&#x95E8;         : &#x786C;&#x4EF6;&#x90E8;&#xFF0C;FPGA&#x5DE5;&#x4F5C;&#x7EC4;&#xD;
//  -- &#x6A21;&#x5757;&#x540D;       : [FILE_NAME]&#xD;
//  -- &#x8BBE;&#x8BA1;&#x8005;       : &#x90A2;&#x6D77;&#x6D9B;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x7248;&#x672C;&#x8BB0;&#x5F55; :&#xD;
//&#xD;
//  -- &#x4F5C;&#x8005;         :| &#x4FEE;&#x6539;&#x65E5;&#x671F;				:|  &#x4FEE;&#x6539;&#x8BF4;&#x660E;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x90A2;&#x6D77;&#x6D9B;       :| [DATE_USER]yyyy/MM/dd[DATE_USER_END] [TIME_USER]HH':'mm':'ss[TIME_USER_END]	:|  &#x521D;&#x59CB;&#x7248;&#x672C;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x6A21;&#x5757;&#x63CF;&#x8FF0;     : &#xD;
//              1)  : &#xD;
//&#xD;
//              2)  : &#xD;
//&#xD;
//              3)  : &#xD;
//&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//`include			"[FILE_NAME]_def.v"&#xD;
//&#x4EFF;&#x771F;&#x5355;&#x4F4D;/&#x7CBE;&#x5EA6;&#xD;
`timescale 1ns/1ps&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
&#xD;
module [FILE_NAME] ();&#xD;
&#xD;
//	ref signals&#xD;
&#xD;
&#xD;
&#xD;
//	ref ARCHITECTURE&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
initial begin&#xD;
	 //$display($time, "Starting the Simulation...");&#xD;
	 //$monitor($time, "count1 is %d,count2 is %b,count3 is %h",cnt1,cnt2,cnt3);&#xD;
	 reset = 1'b1;&#xD;
	 #200&#xD;
	 reset = 1'b0;&#xD;
	 #10000&#xD;
	 $stop;&#xD;
&#xD;
end&#xD;
&#xD;
always #5 clk = ~clk;&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
//generate vcd file&#xD;
//initial begin&#xD;
	 //$dumpfile("test.vcd");&#xD;
	 //$dumpvars(1,top_frame_buffer_inst);&#xD;
//end&#xD;
&#xD;
//for lattice simulation&#xD;
//GSR   GSR_INST (.GSR (1'b1)); //&lt; global reset sig&gt;&#xD;
//PUR   PUR_INST (.PUR (1'b1)); //&lt;powerup reset sig&gt;&#xD;
&#xD;
&#xD;
&#xD;
endmodule&#xD;
&#xD;
&#xD;
</Template><Template Name="repeat" Description="" Comments="0" Strings="0">repeat() @ (posedge clk);</Template><Template Name="wait" Description="" Comments="0" Strings="0">wait([+signal+]==[+value+]);&#xD;
</Template>
<Template Name="display" Description="" Comments="0" Strings="0">$display("%m: at time %t ERROR: fseek to %d failed", $time, offset);</Template>
<Template Name="monitor" Description="" Comments="0" Strings="0">$monitor ("time is %t,reg is %b",$time,a);&#xD;
</Template>



<Template Name="readmemb" Description="" Comments="0" Strings="0">reg [&lt;memory_width&gt;] &lt;reg_name&gt; [&lt;memory_depth&gt;];&#xD;
&#xD;
$readmemb ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);</Template><Template Name="task" Description="" Comments="0" Strings="0">task task_name;&#xD;
	input	clk;&#xD;
	input	full;&#xD;
	reg	wr_reg;&#xD;
&#xD;
	begin&#xD;
		//repeat(30) @ (posedge clk);&#xD;
		//wait(full==1'b0);&#xD;
		//wr_reg	= 1'b1;&#xD;
		//@ (posedge);&#xD;
		//wr_reg	= 1'b0;&#xD;
	end&#xD;
endtask&#xD;
&#xD;
</Template><Template Name="forever" Description="" Comments="0" Strings="0">forever begin&#xD;
	//repeat(4) @ (posedge clk);&#xD;
	//#100;&#xD;
	//div_cnt	= div_cnt + 1'b1;&#xD;
end</Template>

<Template Name="initial" Description="" Comments="0" Strings="0">initial begin&#xD;
	//$display($time, "Starting the Simulation...");&#xD;
	//$monitor($time, "count1 is %d,count2 is %b,count3 is %h",cnt1,cnt2,cnt3);&#xD;
	reset = 1'b1;&#xD;
	#200&#xD;
	reset = 1'b0;&#xD;
	#10000&#xD;
	$stop;&#xD;
&#xD;
end</Template><Template Name="pull" Description="" Comments="0" Strings="0">PULLDOWN pulldown_[+sig+]_inst (.O([+sig+])); PULLUP pullup_[+sig+]_inst (.O([+sig+])); assign ( pull1, strong0 ) [+sig+] = 1'b1;</Template><Template Name="fdisplay" Description="" Comments="0" Strings="0">$fdisplay(file_handle, "rd_ptr is: %h,rd_addr is: %h",rd_ptr,rd_addr);</Template><Template Name="force" Description="" Comments="0" Strings="0">force		c=1; release		c;</Template><Template Name="clk_sim" Description="" Comments="0" Strings="0">always	#(CLK_PERIOD_NS_0/2.0)		clk			= !clk;</Template><Template Name="file" Description="" Comments="0" Strings="0">// Opening Command&#xD;
// ---------------&#xD;
// $fopen is used to open a file for reading, writing and/or appending.&#xD;
// This operation must precede any of the reading or writing commands&#xD;
// specified in this document. When using the $fopen, you must specify&#xD;
// the file name and file mode (read, write, etc.). The syntax looks like&#xD;
// the following: $fopen("&lt;file_name&gt;", "&lt;file_mode&gt;")&#xD;
// Upon opening the file a handle number is issued for the file and must&#xD;
// be used to reference the file in subsequent commands. Generally, this&#xD;
// number should be assigned to a declared integer.&#xD;
//&#xD;
// The file mode can be one of the following:&#xD;
//&#xD;
//    "r" ...... Open ASCII file for reading&#xD;
//    "rb" ..... Open Binary file for reading&#xD;
//    "w" ...... Open ASCII file for writing (delete if exists)&#xD;
//    "wb" ..... Open Binary file for writing (delete if exists)&#xD;
//    "a" ...... Open ASCII file for writing (append to end of file)&#xD;
//    "ab" ..... Open Binary file for writing (append to end of file)&#xD;
//    "r+" ..... Open ASCII file for reading and writing&#xD;
integer &lt;file_desc&gt;;&#xD;
&lt;file_desc&gt; = $fopen("&lt;file_name&gt;", "&lt;file_mode&gt;");&#xD;
&#xD;
// Writing Commands&#xD;
// ----------------&#xD;
// $fdisplay will write formatted text to a specified file. Specific text,&#xD;
// system functions/tasks and signal values can be output using this&#xD;
// function.  The file handle assigned by the $fopen function must be&#xD;
// specified to indicate the destination file for the text.  The syntax looks&#xD;
// as follows:  $fdisplay(&lt;file_desc&gt;, "&lt;string&gt;", variables);&#xD;
$fdisplay(&lt;file_desc&gt;, "&lt;string&gt;", variables);&#xD;
&#xD;
// $fwrite acts very similar to $fdisplay in that it can write a specified&#xD;
// string to a file however it does not specify a carriage return after&#xD;
// performing this operation.&#xD;
$fwrite(&lt;file_desc&gt;, "&lt;string&gt;", variables);&#xD;
&#xD;
// $fstrobe is also similar to $fdisplay only waits for all simulation events&#xD;
// in the queue to be executed before writing the message.&#xD;
$fstrobe(&lt;file_desc&gt;, "&lt;string&gt;", variables);&#xD;
&#xD;
// $fmonitor will write a string to the specified file whenever a change&#xD;
// in value is detected for one of the variables being written.  After&#xD;
// the string is written, a carriage return is issued.&#xD;
$fmonitor(&lt;file_desc&gt;, "&lt;string&gt;", variables);&#xD;
&#xD;
// When using these write commands ($fdisplay, $fwrite, $fstrobe, $fmonitor),&#xD;
// variables can be specified to the output in a variety of formats.  Also,&#xD;
// special escape characters can be used to specify special characters or&#xD;
// formatting.  These formats are listed below.&#xD;
//&#xD;
//    Variables&#xD;
//    ---------&#xD;
//    %b .... Binary Value&#xD;
//    %h .... Hexadecimal Value&#xD;
//    %d .... Decimal Value&#xD;
//    %t .... Time&#xD;
//    %s .... String&#xD;
//    %c .... ASCII&#xD;
//    %f .... Real Value&#xD;
//    %e .... Exponential Value&#xD;
//    %o .... Octal Value&#xD;
//    %m .... Module Hierarchical Name&#xD;
//    %v .... Strength&#xD;
//&#xD;
//    Escape Characters&#xD;
//    -----------------&#xD;
//    \t ........ Tab&#xD;
//    \n ........ Newline&#xD;
//    \\ ........ Backslash&#xD;
//    %% ........ Percent&#xD;
//    \" ........ Quote&#xD;
//    \&lt;octal&gt; .. ASCII representation&#xD;
&#xD;
// Reading Commands&#xD;
// ----------------&#xD;
// $fgets will read an entire line of text from a file and store it as a&#xD;
// string. The format for $fgets is: $fgets(&lt;string_reg&gt;, &lt;file_desc&gt;);&#xD;
// $fgets returns an integer value either indicating the number of characters&#xD;
// read or a zero indication an error during the read attempt.  The &lt;string_reg&gt;&#xD;
// should be defined a width equal to the number of characters on the longest&#xD;
// line multiplied by 8.&#xD;
//&#xD;
// $fgetc will read a character from a file and return it as an 8-bit string.&#xD;
// If EOF is encountered, a value of -1 is written.&#xD;
reg [7:0] &lt;8-bit_reg&gt;;&#xD;
&lt;8-bit_reg&gt; = $fgetc(&lt;file_desc&gt;);&#xD;
&#xD;
integer &lt;integer&gt;;&#xD;
reg [8*&lt;#_of_chars&gt;:0] &lt;string_reg&gt;;&#xD;
&lt;integer&gt; = $fgets(&lt;string_reg&gt;, &lt;file_desc&gt;);&#xD;
&#xD;
// $fscanf will read a line from a file and store it in a specified form. The&#xD;
// format for the $fsacnf is: $fscanf(&lt;file_desc&gt;, &lt;format&gt;, &lt;destination_regs&gt;)&#xD;
// where the format is specified similar to how it is specified in the read&#xD;
// command above and the &lt;destination_regs&gt; is where the read data is stored.&#xD;
// $fscanf will return an integer value indicating the number of matched&#xD;
// formatted data read. If an error occurs during the read, this number will&#xD;
// be zero.&#xD;
integer &lt;integer&gt;;&#xD;
&lt;integer&gt; = $fscanf(&lt;file_desc&gt;, "&lt;format&gt;", &lt;destination_regs&gt;);&#xD;
&#xD;
// Special Functions&#xD;
// -----------------&#xD;
// $ferror tests and reports last error encountered during a file open, read&#xD;
// or write.  The written string can be up to 80 characters (640 bits) wide.&#xD;
//&#xD;
// $fseek will reposition the pointer within the file to the specified position.&#xD;
// The format for the $fseek command is:&#xD;
// $fseek(&lt;file_desc&gt;, &lt;offset_value&gt;, &lt;operation_number&gt;) where the operation&#xD;
// number is one of three values:&#xD;
// 0 - set position using the beginning of file as the reference point&#xD;
// 1 - set position using the current location of the pointer as reference&#xD;
// 2 - set position using the EOF as reference&#xD;
// $fseek will return a zero if the command was successful and a -1 if not.&#xD;
&lt;integer&gt; = $fseek(&lt;file_desc&gt;, &lt;offset_value&gt;, &lt;operation_number&gt;);&#xD;
&#xD;
// $ftell specifies the position of the pointer within the file by outputting an&#xD;
// integer value indicating the number of offset bytes from the beginning of the&#xD;
// file.&#xD;
&lt;reg&gt; = $ftell(&lt;file_desc&gt;);&#xD;
&#xD;
// $fflush writes any buffered output to the specified file.&#xD;
$fflush(&lt;file_desc&gt;);&#xD;
&#xD;
&lt;640-bit_reg&gt; = $ferror(&lt;file_desc&gt;);&#xD;
&#xD;
// Close File&#xD;
// ----------&#xD;
// $fclose closes a previous opened file.  The format is $fclose(&lt;file_desc&gt;);&#xD;
$fclose(&lt;file_desc&gt;);</Template><Template Name="***&#x5668;&#x4EF6;&#x539F;&#x8BED;***" Description="" Comments="0" Strings="0"/><Template Name="bufg" Description="" Comments="0" Strings="0">//spartan6&#xD;
IBUFG ibufg_inst (&#xD;
.I	(I	),&#xD;
.O	(O	)&#xD;
);&#xD;
&#xD;
BUFG bufg_inst (&#xD;
.I	(I	),&#xD;
.O	(O	)&#xD;
);&#xD;
&#xD;
IBUFGDS # (&#xD;
.DIFF_TERM	("TRUE"	)	// TRUE or FALSE&#xD;
)&#xD;
ibufgds_inst (&#xD;
.I	(I	),&#xD;
.IB	(IB	),&#xD;
.O	(O	)&#xD;
);&#xD;
&#xD;
IBUFDS # (&#xD;
.DIFF_TERM	("TRUE"	)	// TRUE or FALSE&#xD;
)&#xD;
ibufgds_inst (&#xD;
.I	(I	),&#xD;
.IB	(IB	),&#xD;
.O	(O	)&#xD;
);&#xD;
&#xD;
OBUFDS obufds_inst (&#xD;
.I	(I	),&#xD;
.O	(O	),&#xD;
.OB	(OB	)&#xD;
);&#xD;
&#xD;
BUFGMUX # (&#xD;
.CLK_SEL_TYPE	("SYNC")  // Glitchles ("SYNC") or fast ("ASYNC") clock switch-over,&#xD;
)&#xD;
BUFGMUX_inst (&#xD;
.O		(O	),	// 1-bit output: Clock buffer output&#xD;
.I0		(I0	),	// 1-bit input: Clock buffer input (S=0)&#xD;
.I1		(I1	),	// 1-bit input: Clock buffer input (S=1)&#xD;
.S		(S	)	// 1-bit input: Clock buffer select&#xD;
);&#xD;
&#xD;
BUFGCE bufgce_inst (&#xD;
.I	(I	),	// 1-bit input: Clock buffer input (S=0)&#xD;
.CE	(CE	),	// 1-bit input: Clock buffer select&#xD;
.O	(O	)	// 1-bit output: Clock buffer output&#xD;
);</Template><Template Name="oddr2" Description="" Comments="0" Strings="0">ODDR2 # (&#xD;
.DDR_ALIGNMENT	("C0"			),	// Sets output alignment to "NONE", "C0" or "C1"&#xD;
.INIT			(1'b0			),  // Sets initial state of the Q output to 1'b0 or 1'b1&#xD;
.SRTYPE			("ASYNC"		)	// Specifies "SYNC" or "ASYNC" set/reset&#xD;
)&#xD;
ODDR2_txc_inst (&#xD;
.Q				(src_clk_odelay	),&#xD;
.C0				(!src_clk		),&#xD;
.C1				(src_clk		),&#xD;
.CE				(1'b1			),&#xD;
.D0				(1'b1			),&#xD;
.D1				(1'b0			),&#xD;
.R				(1'b0			),&#xD;
.S				(1'b0			)&#xD;
);&#xD;
</Template><Template Name="iodelay2" Description="" Comments="0" Strings="0">IODELAY2 # (&#xD;
.IDELAY_TYPE      	("FIXED"		),	// "FIXED", "DEFAULT", "VARIABLE_FROM_ZERO", "VARIABLE_FROM_HALF_MAX" or "DIFF_PHASE_DETECTOR"&#xD;
.ODELAY_VALUE     	(0				),	// Amount of taps fixed output delay (0-255)&#xD;
.DELAY_SRC        	("ODATAIN"		),	// "IO", "ODATAIN" or "IDATAIN"&#xD;
.SIM_TAPDELAY_VALUE	(75				)	// Per tap delay used for simulation in ps&#xD;
)&#xD;
delay_txc_inst (&#xD;
.BUSY			(				),&#xD;
.DATAOUT		(				),&#xD;
.DATAOUT2		(				),&#xD;
.DOUT			(o_tx_clk		),&#xD;
.TOUT			(				),&#xD;
.CAL			(1'b0			),&#xD;
.CE				(1'b0			),&#xD;
.CLK			(1'b0			),&#xD;
.IDATAIN		(1'b0			),&#xD;
.INC			(1'b0			),&#xD;
.IOCLK0			(1'b0			),&#xD;
.IOCLK1			(1'b0			),&#xD;
.ODATAIN		(src_clk_odelay	),&#xD;
.RST			(1'b0			),&#xD;
.T				(1'b0			)&#xD;
);</Template><Template Name="dcm" Description="" Comments="0" Strings="0">//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x7248;&#x6743;&#x6240;&#x6709;&#x8005;   : &#x4E2D;&#x56FD;&#x5927;&#x6052;&#xFF08;&#x96C6;&#x56E2;&#xFF09;&#x6709;&#x9650;&#x516C;&#x53F8;&#x5317;&#x4EAC;&#x56FE;&#x50CF;&#x89C6;&#x89C9;&#x6280;&#x672F;&#x5206;&#x516C;&#x53F8;, 2010 -2015.&#xD;
//  -- &#x4FDD;&#x5BC6;&#x7EA7;&#x522B;     &#xFF1A;&#x7EDD;&#x5BC6;.&#xD;
//  -- &#x90E8;&#x95E8;         : &#x786C;&#x4EF6;&#x90E8;&#xFF0C;FPGA&#x5DE5;&#x4F5C;&#x7EC4;&#xD;
//  -- &#x6A21;&#x5757;&#x540D;       : [FILE_NAME]&#xD;
//  -- &#x8BBE;&#x8BA1;&#x8005;       : &#x90A2;&#x6D77;&#x6D9B;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x7248;&#x672C;&#x8BB0;&#x5F55; :&#xD;
//&#xD;
//  -- &#x4F5C;&#x8005;         :| &#x4FEE;&#x6539;&#x65E5;&#x671F;				:|  &#x4FEE;&#x6539;&#x8BF4;&#x660E;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x90A2;&#x6D77;&#x6D9B;       :| [DATE_USER]yyyy/MM/dd[DATE_USER_END] [TIME_USER]HH':'mm':'ss[TIME_USER_END]	:|  &#x521D;&#x59CB;&#x7248;&#x672C;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x6A21;&#x5757;&#x63CF;&#x8FF0;     :&#xD;
//              1)  : ... ...&#xD;
//&#xD;
//              2)  : ... ...&#xD;
//&#xD;
//              3)  : ... ...&#xD;
//&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#x4EFF;&#x771F;&#x5355;&#x4F4D;/&#x7CBE;&#x5EA6;&#xD;
`timescale 1ns/1ps&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
&#xD;
module [FILE_NAME] (&#xD;
	input         clk_in		,&#xD;
	input         dcm_reset		,&#xD;
	output        clk_fx_out	,&#xD;
	output        locked&#xD;
	);&#xD;
&#xD;
&#xD;
	wire 		[7:0]  	status_int		;&#xD;
	wire 				clkfb			;&#xD;
	wire 				clk0			;&#xD;
	wire 				clkfx			;&#xD;
&#xD;
&#xD;
	//	ref signals&#xD;
&#xD;
	//	ref ARCHITECTURE&#xD;
&#xD;
//  -------------------------------------------------------------------------------------&#xD;
//	dcm &#x4F8B;&#x5316;&#xD;
//  -------------------------------------------------------------------------------------&#xD;
	DCM_SP # (&#xD;
	.CLKDV_DIVIDE          (2.000				),&#xD;
	.CLKFX_DIVIDE          (5					),&#xD;
	.CLKFX_MULTIPLY        (12					),&#xD;
	.CLKIN_DIVIDE_BY_2     ("FALSE"				),&#xD;
	.CLKIN_PERIOD          (25.0				),&#xD;
	.CLKOUT_PHASE_SHIFT    ("NONE"				),&#xD;
	.CLK_FEEDBACK          ("1X"				),&#xD;
	.DESKEW_ADJUST         ("SYSTEM_SYNCHRONOUS"),&#xD;
	.PHASE_SHIFT           (0					),&#xD;
	.STARTUP_WAIT          ("FALSE"				)&#xD;
	)&#xD;
	dcm_sp_inst (&#xD;
	// Input clocks&#xD;
	.CLKIN                 (clk_in	),&#xD;
	.CLKFB                 (clkfb	),&#xD;
	// Output clocks&#xD;
	.CLK0                  (clk0	),&#xD;
	.CLK90                 (),&#xD;
	.CLK180                (),&#xD;
	.CLK270                (),&#xD;
	.CLK2X                 (),&#xD;
	.CLK2X180              (),&#xD;
	.CLKFX                 (clkfx	),&#xD;
	.CLKFX180              (),&#xD;
	.CLKDV                 (),&#xD;
	// Ports for dynamic phase shift&#xD;
	.PSCLK                 (1'b0	),&#xD;
	.PSEN                  (1'b0	),&#xD;
	.PSINCDEC              (1'b0	),&#xD;
	.PSDONE                (),&#xD;
	// Other control and status signals&#xD;
	.LOCKED                (locked		),&#xD;
	.STATUS                (status_int	),&#xD;
	.RST                   (dcm_reset	),&#xD;
	// Unused pin- tie low&#xD;
	.DSSEN                 (1'b0		)&#xD;
	);&#xD;
&#xD;
	&#xD;
&#xD;
//  -------------------------------------------------------------------------------------&#xD;
//	&#x65F6;&#x949F;&#xD;
//  -------------------------------------------------------------------------------------&#xD;
	BUFG clkf_buf (&#xD;
	.I		(clk0	),&#xD;
	.O		(clkfb	)&#xD;
	);&#xD;
&#xD;
	BUFG clkout1_buf (&#xD;
	.I		(clkfx		),&#xD;
	.O		(clk_fx_out	)&#xD;
	);&#xD;
&#xD;
&#xD;
&#xD;
endmodule</Template><Template Name="xpm_fifo_sync" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | DOUT_RESET_VALUE     | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset value of read data path.                                                                                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, en_ecc. Default value = no_ecc.                 |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  "no_ecc" - Disables ECC                                                                                            |&#xD;
// |   "en_ecc" - Enables both ECC Encoder and Decoder                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_MEMORY_TYPE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the fifo memory primitive (resource type) to use-                                                         |&#xD;
// |                                                                                                                     |&#xD;
// |  "auto"- Allow Vivado Synthesis to choose                                                                           |&#xD;
// |   "block"- Block RAM FIFO                                                                                           |&#xD;
// |   "distributed"- Distributed RAM FIFO                                                                               |&#xD;
// |   "ultra"- URAM FIFO                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_READ_LATENCY    | Integer            | Range: 0 - 100. Default value = 1.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Number of output register stages in the read data path                                                              |&#xD;
// |                                                                                                                     |&#xD;
// |  If READ_MODE = "fwft", then the only applicable value is 0                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_WRITE_DEPTH     | Integer            | Range: 16 - 4194304. Default value = 2048.                              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the FIFO Write Depth, must be power of two                                                                  |&#xD;
// |                                                                                                                     |&#xD;
// |  In standard READ_MODE, the effective depth = FIFO_WRITE_DEPTH                                                      |&#xD;
// |   In First-Word-Fall-Through READ_MODE, the effective depth = FIFO_WRITE_DEPTH+2                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FULL_RESET_VALUE     | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Sets full, almost_full and prog_full to FULL_RESET_VALUE during reset                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | PROG_EMPTY_THRESH    | Integer            | Range: 3 - 4194304. Default value = 3.                                  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted.                    |&#xD;
// |                                                                                                                     |&#xD;
// |  Min_Value = 3 + (READ_MODE_VAL*2)                                                                                  |&#xD;
// |   Max_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE_VAL*2)                                                              |&#xD;
// |                                                                                                                     |&#xD;
// | If READ_MODE = "std", then READ_MODE_VAL = 0; Otherwise READ_MODE_VAL = 1                                           |&#xD;
// | NOTE: The default threshold value is dependent on default FIFO_WRITE_DEPTH value. If FIFO_WRITE_DEPTH value is      |&#xD;
// | changed, ensure the threshold value is within the valid range though the programmable flags are not used.           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | PROG_FULL_THRESH     | Integer            | Range: 3 - 4194301. Default value = 3.                                  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |&#xD;
// |                                                                                                                     |&#xD;
// |  Min_Value = 3 + (READ_MODE_VAL*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                                               |&#xD;
// |   Max_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE_VAL*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                           |&#xD;
// |                                                                                                                     |&#xD;
// | If READ_MODE = "std", then READ_MODE_VAL = 0; Otherwise READ_MODE_VAL = 1                                           |&#xD;
// | NOTE: The default threshold value is dependent on default FIFO_WRITE_DEPTH value. If FIFO_WRITE_DEPTH value is      |&#xD;
// | changed, ensure the threshold value is within the valid range though the programmable flags are not used.           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | RD_DATA_COUNT_WIDTH  | Integer            | Range: 1 - 23. Default value = 1.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the width of rd_data_count                                                                                |&#xD;
// |                                                                                                                     |&#xD;
// |  FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH      | Integer            | Range: 1 - 4096. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the width of the read data port, dout                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_MODE            | String             | Allowed values: std, fwft. Default value = std.                         |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  "std"- standard read mode                                                                                          |&#xD;
// |   "fwft"- First-Word-Fall-Through read mode                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_ADV_FEATURES     | String             | Default value = 0707.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Enables data_valid, almost_empty, rd_data_count, prog_empty, underflow, wr_ack, almost_full, wr_data_count,         |&#xD;
// | prog_full, overflow features.                                                                                       |&#xD;
// |                                                                                                                     |&#xD;
// |  Setting USE_ADV_FEATURES[0]  to 1 enables overflow flag;     Default value of this bit is 1                        |&#xD;
// |   Setting USE_ADV_FEATURES[1]  to 1 enables prog_full flag;    Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[2]  to 1 enables wr_data_count;     Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[3]  to 1 enables almost_full flag;  Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[4]  to 1 enables wr_ack flag;       Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[8]  to 1 enables underflow flag;    Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[9]  to 1 enables prog_empty flag;   Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[10] to 1 enables rd_data_count;     Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[11] to 1 enables almost_empty flag; Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[12] to 1 enables data_valid flag;   Default value of this bit is 0                       |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | Integer            | Range: 0 - 2. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  0 - Disable sleep                                                                                                  |&#xD;
// |   2 - Use Sleep Pin                                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH     | Integer            | Range: 1 - 4096. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the width of the write data port, din                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WR_DATA_COUNT_WIDTH  | Integer            | Range: 1 - 23. Default value = 1.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the width of wr_data_count                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | almost_empty   | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Almost Empty : When asserted, this signal indicates that only one more read can be performed before the FIFO goes to|&#xD;
// | empty.                                                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | almost_full    | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Almost Full: When asserted, this signal indicates that only one more write can be performed before the FIFO is full.|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | data_valid     | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data Valid: When asserted, this signal indicates that valid data is available on the output bus (dout).        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterr        | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | din            | Input     | WRITE_DATA_WIDTH                      | wr_clk  |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Data: The input data bus used when writing the FIFO.                                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dout           | Output    | READ_DATA_WIDTH                       | wr_clk  |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data: The output data bus is driven when reading the FIFO.                                                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | empty          | Output    | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |&#xD;
// | Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | full           | Output    | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |&#xD;
// | Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |&#xD;
// | to the contents of the FIFO.                                                                                        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterr  | Input     | 1                                     | wr_clk  | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |&#xD;
// | UltraRAM macros.                                                                                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterr  | Input     | 1                                     | wr_clk  | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |&#xD;
// | UltraRAM macros.                                                                                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | overflow       | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |&#xD;
// | because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | prog_empty     | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |&#xD;
// | to the programmable empty threshold value.                                                                          |&#xD;
// | It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | prog_full      | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |&#xD;
// | to the programmable full threshold value.                                                                           |&#xD;
// | It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | wr_clk  |             | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data Count: This bus indicates the number of words read from the FIFO.                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_en          | Input     | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO.        |&#xD;
// |                                                                                                                     |&#xD;
// |  Must be held active-low when rd_rst_busy is active high.                                                           |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_rst_busy    | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rst            | Input     | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset: Must be synchronous to wr_clk. Must be applied only when wr_clk is stable and free-running.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterr        | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Dynamic power saving- If sleep is High, the memory/fifo block is in power saving mode.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | underflow      | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |&#xD;
// | because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_ack         | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Acknowledge: This signal indicates that a write request (wr_en) during the prior clock cycle is succeeded.    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_clk         | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write clock: Used for write operation. wr_clk must be a free running clock.                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk  |             | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Data Count: This bus indicates the number of words written into the FIFO.                                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_en          | Input     | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO         |&#xD;
// |                                                                                                                     |&#xD;
// |  Must be held active-low when rst or wr_rst_busy or rd_rst_busy is active high                                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_rst_busy    | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
&#xD;
xpm_fifo_sync #(&#xD;
.DOUT_RESET_VALUE("0"),    // String&#xD;
.ECC_MODE("no_ecc"),       // String&#xD;
.FIFO_MEMORY_TYPE("auto"), // String&#xD;
.FIFO_READ_LATENCY(1),     // DECIMAL&#xD;
.FIFO_WRITE_DEPTH(2048),   // DECIMAL&#xD;
.FULL_RESET_VALUE(0),      // DECIMAL&#xD;
.PROG_EMPTY_THRESH(3),     // DECIMAL&#xD;
.PROG_FULL_THRESH(3),      // DECIMAL&#xD;
.RD_DATA_COUNT_WIDTH(1),   // DECIMAL&#xD;
.READ_DATA_WIDTH(32),      // DECIMAL&#xD;
.READ_MODE("std"),         // String&#xD;
.USE_ADV_FEATURES("0707"), // String&#xD;
.WAKEUP_TIME(0),           // DECIMAL&#xD;
.WRITE_DATA_WIDTH(32),     // DECIMAL&#xD;
.WR_DATA_COUNT_WIDTH(1)    // DECIMAL&#xD;
)&#xD;
xpm_fifo_sync_inst (&#xD;
.almost_empty(almost_empty),   // 1-bit output: Almost Empty : When asserted, this signal indicates that&#xD;
// only one more read can be performed before the FIFO goes to empty.&#xD;
&#xD;
.almost_full(almost_full),     // 1-bit output: Almost Full: When asserted, this signal indicates that&#xD;
// only one more write can be performed before the FIFO is full.&#xD;
&#xD;
.data_valid(data_valid),       // 1-bit output: Read Data Valid: When asserted, this signal indicates&#xD;
// that valid data is available on the output bus (dout).&#xD;
&#xD;
.dbiterr(dbiterr),             // 1-bit output: Double Bit Error: Indicates that the ECC decoder detected&#xD;
// a double-bit error and data in the FIFO core is corrupted.&#xD;
&#xD;
.dout(dout),                   // READ_DATA_WIDTH-bit output: Read Data: The output data bus is driven&#xD;
// when reading the FIFO.&#xD;
&#xD;
.empty(empty),                 // 1-bit output: Empty Flag: When asserted, this signal indicates that the&#xD;
// FIFO is empty. Read requests are ignored when the FIFO is empty,&#xD;
// initiating a read while empty is not destructive to the FIFO.&#xD;
&#xD;
.full(full),                   // 1-bit output: Full Flag: When asserted, this signal indicates that the&#xD;
// FIFO is full. Write requests are ignored when the FIFO is full,&#xD;
// initiating a write when the FIFO is full is not destructive to the&#xD;
// contents of the FIFO.&#xD;
&#xD;
.overflow(overflow),           // 1-bit output: Overflow: This signal indicates that a write request&#xD;
// (wren) during the prior clock cycle was rejected, because the FIFO is&#xD;
// full. Overflowing the FIFO is not destructive to the contents of the&#xD;
// FIFO.&#xD;
&#xD;
.prog_empty(prog_empty),       // 1-bit output: Programmable Empty: This signal is asserted when the&#xD;
// number of words in the FIFO is less than or equal to the programmable&#xD;
// empty threshold value. It is de-asserted when the number of words in&#xD;
// the FIFO exceeds the programmable empty threshold value.&#xD;
&#xD;
.prog_full(prog_full),         // 1-bit output: Programmable Full: This signal is asserted when the&#xD;
// number of words in the FIFO is greater than or equal to the&#xD;
// programmable full threshold value. It is de-asserted when the number of&#xD;
// words in the FIFO is less than the programmable full threshold value.&#xD;
&#xD;
.rd_data_count(rd_data_count), // RD_DATA_COUNT_WIDTH-bit output: Read Data Count: This bus indicates the&#xD;
// number of words read from the FIFO.&#xD;
&#xD;
.rd_rst_busy(rd_rst_busy),     // 1-bit output: Read Reset Busy: Active-High indicator that the FIFO read&#xD;
// domain is currently in a reset state.&#xD;
&#xD;
.sbiterr(sbiterr),             // 1-bit output: Single Bit Error: Indicates that the ECC decoder detected&#xD;
// and fixed a single-bit error.&#xD;
&#xD;
.underflow(underflow),         // 1-bit output: Underflow: Indicates that the read request (rd_en) during&#xD;
// the previous clock cycle was rejected because the FIFO is empty. Under&#xD;
// flowing the FIFO is not destructive to the FIFO.&#xD;
&#xD;
.wr_ack(wr_ack),               // 1-bit output: Write Acknowledge: This signal indicates that a write&#xD;
// request (wr_en) during the prior clock cycle is succeeded.&#xD;
&#xD;
.wr_data_count(wr_data_count), // WR_DATA_COUNT_WIDTH-bit output: Write Data Count: This bus indicates&#xD;
// the number of words written into the FIFO.&#xD;
&#xD;
.wr_rst_busy(wr_rst_busy),     // 1-bit output: Write Reset Busy: Active-High indicator that the FIFO&#xD;
// write doma</Template><Template Name="xpm_fifo_async" Description="" Comments="0" Strings="0">// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | CDC_SYNC_STAGES      | Integer            | Range: 2 - 8. Default value = 2.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the number of synchronization stages on the CDC path                                                      |&#xD;
// |                                                                                                                     |&#xD;
// |  Must be &lt; 5 if FIFO_WRITE_DEPTH = 16                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | DOUT_RESET_VALUE     | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset value of read data path.                                                                                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, en_ecc. Default value = no_ecc.                 |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  "no_ecc" - Disables ECC                                                                                            |&#xD;
// |   "en_ecc" - Enables both ECC Encoder and Decoder                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_MEMORY_TYPE     | String             | Allowed values: auto, block, distributed. Default value = auto.         |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the fifo memory primitive (resource type) to use-                                                         |&#xD;
// |                                                                                                                     |&#xD;
// |  "auto"- Allow Vivado Synthesis to choose                                                                           |&#xD;
// |   "block"- Block RAM FIFO                                                                                           |&#xD;
// |   "distributed"- Distributed RAM FIFO                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_READ_LATENCY    | Integer            | Range: 0 - 10. Default value = 1.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Number of output register stages in the read data path.                                                             |&#xD;
// |                                                                                                                     |&#xD;
// |  If READ_MODE = "fwft", then the only applicable value is 0.                                                        |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FIFO_WRITE_DEPTH     | Integer            | Range: 16 - 4194304. Default value = 2048.                              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the FIFO Write Depth, must be power of two                                                                  |&#xD;
// |                                                                                                                     |&#xD;
// |  In standard READ_MODE, the effective depth = FIFO_WRITE_DEPTH-1                                                    |&#xD;
// |   In First-Word-Fall-Through READ_MODE, the effective depth = FIFO_WRITE_DEPTH+1                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | FULL_RESET_VALUE     | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Sets full, almost_full and prog_full to FULL_RESET_VALUE during reset                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | PROG_EMPTY_THRESH    | Integer            | Range: 3 - 4194301. Default value = 5.                                  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted.                    |&#xD;
// |                                                                                                                     |&#xD;
// |   Min_Value = 3 + (READ_MODE_VAL*2)                                                                                 |&#xD;
// |   Max_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE_VAL*2)                                                              |&#xD;
// |                                                                                                                     |&#xD;
// | If READ_MODE = "std", then READ_MODE_VAL = 0; Otherwise READ_MODE_VAL = 1                                           |&#xD;
// | NOTE: The default threshold value is dependent on default FIFO_WRITE_DEPTH value. If FIFO_WRITE_DEPTH value is      |&#xD;
// | changed, ensure the threshold value is within the valid range though the programmable flags are not used.           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | PROG_FULL_THRESH     | Integer            | Range: 5 - 4194301. Default value = 5.                                  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |&#xD;
// |                                                                                                                     |&#xD;
// |  Min_Value = 3 + (READ_MODE_VAL*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))+CDC_SYNC_STAGES                               |&#xD;
// |   Max_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE_VAL*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                           |&#xD;
// |                                                                                                                     |&#xD;
// | If READ_MODE = "std", then READ_MODE_VAL = 0; Otherwise READ_MODE_VAL = 1                                           |&#xD;
// | NOTE: The default threshold value is dependent on default FIFO_WRITE_DEPTH value. If FIFO_WRITE_DEPTH value is      |&#xD;
// | changed, ensure the threshold value is within the valid range though the programmable flags are not used.           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | RD_DATA_COUNT_WIDTH  | Integer            | Range: 1 - 23. Default value = 1.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the width of rd_data_count                                                                                |&#xD;
// |                                                                                                                     |&#xD;
// |  FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH      | Integer            | Range: 1 - 4096. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the width of the read data port, dout                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_MODE            | String             | Allowed values: std, fwft. Default value = std.                         |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  "std"- standard read mode                                                                                          |&#xD;
// |   "fwft"- First-Word-Fall-Through read mode                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | RELATED_CLOCKS       | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies if the wr_clk and rd_clk are related having the same source but different clock ratios                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_ADV_FEATURES     | String             | Default value = 0707.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Enables data_valid, almost_empty, rd_data_count, prog_empty, underflow, wr_ack, almost_full, wr_data_count,         |&#xD;
// | prog_full, overflow features.                                                                                       |&#xD;
// |                                                                                                                     |&#xD;
// |  Setting USE_ADV_FEATURES[0]  to 1 enables overflow flag;     Default value of this bit is 1                        |&#xD;
// |   Setting USE_ADV_FEATURES[1]  to 1 enables prog_full flag;    Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[2]  to 1 enables wr_data_count;     Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[3]  to 1 enables almost_full flag;  Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[4]  to 1 enables wr_ack flag;       Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[8]  to 1 enables underflow flag;    Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[9]  to 1 enables prog_empty flag;   Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[10] to 1 enables rd_data_count;     Default value of this bit is 1                       |&#xD;
// |   Setting USE_ADV_FEATURES[11] to 1 enables almost_empty flag; Default value of this bit is 0                       |&#xD;
// |   Setting USE_ADV_FEATURES[12] to 1 enables data_valid flag;   Default value of this bit is 0                       |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | Integer            | Range: 0 - 2. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// |                                                                                                                     |&#xD;
// |  0 - Disable sleep                                                                                                  |&#xD;
// |   2 - Use Sleep Pin                                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH     | Integer            | Range: 1 - 4096. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Defines the width of the write data port, din                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WR_DATA_COUNT_WIDTH  | Integer            | Range: 1 - 23. Default value = 1.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specifies the width of wr_data_count                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | almost_empty   | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Almost Empty : When asserted, this signal indicates that only one more read can be performed before the FIFO goes to|&#xD;
// | empty.                                                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | almost_full    | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Almost Full: When asserted, this signal indicates that only one more write can be performed before the FIFO is full.|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | data_valid     | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data Valid: When asserted, this signal indicates that valid data is available on the output bus (dout).        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterr        | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | din            | Input     | WRITE_DATA_WIDTH                      | wr_clk  |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Data: The input data bus used when writing the FIFO.                                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dout           | Output    | READ_DATA_WIDTH                       | rd_clk  |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data: The output data bus is driven when reading the FIFO.                                                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | empty          | Output    | 1                                     | rd_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |&#xD;
// | Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | full           | Output    | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |&#xD;
// | Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |&#xD;
// | to the contents of the FIFO.                                                                                        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterr  | Input     | 1                                     | wr_clk  | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |&#xD;
// | UltraRAM macros.                                                                                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterr  | Input     | 1                                     | wr_clk  | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |&#xD;
// | UltraRAM macros.                                                                                                    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | overflow       | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |&#xD;
// | because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | prog_empty     | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |&#xD;
// | to the programmable empty threshold value.                                                                          |&#xD;
// | It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | prog_full      | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |&#xD;
// | to the programmable full threshold value.                                                                           |&#xD;
// | It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_clk         | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read clock: Used for read operation. rd_clk must be a free running clock.                                           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | rd_clk  |             | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Data Count: This bus indicates the number of words read from the FIFO.                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_en          | Input     | 1                                     | rd_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO.        |&#xD;
// |                                                                                                                     |&#xD;
// |  Must be held active-low when rd_rst_busy is active high.                                                           |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rd_rst_busy    | Output    | 1                                     | rd_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rst            | Input     | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset: Must be synchronous to wr_clk. Must be applied only when wr_clk is stable and free-running.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterr        | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Dynamic power saving: If sleep is High, the memory/fifo block is in power saving mode.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | underflow      | Output    | 1                                     | rd_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |&#xD;
// | because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_ack         | Output    | 1                                     | wr_clk  | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Acknowledge: This signal indicates that a write request (wr_en) during the prior clock cycle is succeeded.    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_clk         | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write clock: Used for write operation. wr_clk must be a free running clock.                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk  |             | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Data Count: This bus indicates the number of words written into the FIFO.                                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_en          | Input     | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO.        |&#xD;
// |                                                                                                                     |&#xD;
// |  Must be held active-low when rst or wr_rst_busy is active high.                                                    |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wr_rst_busy    | Output    | 1                                     | wr_clk  | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
xpm_fifo_async #(&#xD;
.CDC_SYNC_STAGES(2),       // DECIMAL&#xD;
.DOUT_RESET_VALUE("0"),    // String&#xD;
.ECC_MODE("no_ecc"),       // String&#xD;
.FIFO_MEMORY_TYPE("auto"), // String&#xD;
.FIFO_READ_LATENCY(1),     // DECIMAL&#xD;
.FIFO_WRITE_DEPTH(2048),   // DECIMAL&#xD;
.FULL_RESET_VALUE(0),      // DECIMAL&#xD;
.PROG_EMPTY_THRESH(5),     // DECIMAL&#xD;
.PROG_FULL_THRESH(5),      // DECIMAL&#xD;
.RD_DATA_COUNT_WIDTH(1),   // DECIMAL&#xD;
.READ_DATA_WIDTH(32),      // DECIMAL&#xD;
.READ_MODE("std"),         // String&#xD;
.RELATED_CLOCKS(0),        // DECIMAL&#xD;
.USE_ADV_FEATURES("0707"), // String&#xD;
.WAKEUP_TIME(0),           // DECIMAL&#xD;
.WRITE_DATA_WIDTH(32),     // DECIMAL&#xD;
.WR_DATA_COUNT_WIDTH(1)    // DECIMAL&#xD;
)&#xD;
xpm_fifo_async_inst (&#xD;
.almost_empty(almost_empty),   // 1-bit output: Almost Empty : When asserted, this signal indicates that&#xD;
// only one more read can be performed before the FIFO goes to empty.&#xD;
&#xD;
.almost_full(almost_full),     // 1-bit output: Almost Full: When asserted, this signal indicates that&#xD;
// only one more write can be performed before the FIFO is full.&#xD;
&#xD;
.data_valid(data_valid),       // 1-bit output: Read Data Valid: When asserted, this signal indicates&#xD;
// that valid data is available on the output bus (dout).&#xD;
&#xD;
.dbiterr(dbiterr),             // 1-bit output: Double Bit Error: Indicates that the ECC decoder detected&#xD;
// a double-bit error and data in the FIFO core is corrupted.&#xD;
&#xD;
.dout(dout),                   // READ_DATA_WIDTH-bit output: Read Data: The output data bus is driven&#xD;
// when reading the FIFO.&#xD;
&#xD;
.empty(empty),                 // 1-bit output: Empty Flag: When asserted, this signal indicates that the&#xD;
// FIFO is empty. Read requests are ignored when the FIFO is empty,&#xD;
// initiating a read while empty is not destructive to the FIFO.&#xD;
&#xD;
.full(full),                   // 1-bit output: Full Flag: When asserted, this signal indicates that the&#xD;
// FIFO is full. Write requests are ignored when the FIFO is full,&#xD;
// initiating a write when the FIFO is full is not destructive to the&#xD;
// contents of the FIFO.&#xD;
&#xD;
.overflow(overflow),           // 1-bit output: Ove</Template><Template Name="***&#x6210;&#x719F;&#x4EE3;&#x7801;&#x6BB5;-logic***" Description="" Comments="0" Strings="0"/><Template Name="xpm_mem_dpdistram" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A). |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_B         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B address port addrb, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port B, i.e. = $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B). |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | BYTE_WRITE_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | To enable byte-wide writes on port A, specify the byte width, in bits-                                              |&#xD;
// |                                                                                                                     |&#xD;
// |  8- 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                               |&#xD;
// |   9- 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |&#xD;
// |                                                                                                                     |&#xD;
// | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | CLOCKING_MODE        | String             | Allowed values: common_clock, independent_clock. Default value = common_clock.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate whether port A and port B are clocked with a common clock or with independent clocks-                     |&#xD;
// |                                                                                                                     |&#xD;
// |  "common_clock"- Common clocking; clock both port A and port B with clka                                            |&#xD;
// |   "independent_clock"- Independent clocking; clock port A with clka and port B with clkb                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                       |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                           | |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | | |                                                                                                                 |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 RAM.                                                                           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_A    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A read data output port douta, in bits.                                               |&#xD;
// | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_B    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B read data output port doutb, in bits.                                               |&#xD;
// | The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_A       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |&#xD;
// | number of clka cycles.                                                                                              |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output. |&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_B       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |&#xD;
// | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output. |&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_A   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |&#xD;
// | The value mentioned must be accomodated in READ_DATA_WIDTH_A number of bits.                                        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_B   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |&#xD;
// | The value mentioned must be accomodated in READ_DATA_WIDTH_B number of bits.                                        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_EMBEDDED_CONSTRAINT| Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the set_false_path constraint addition between clka of Distributed RAM and doutb_reg on clkb    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A write data input port dina, in bits.                                                |&#xD;
// | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A write and read operations.                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addrb          | Input     | ADDR_WIDTH_B                          | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port B write and read operations.                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clkb           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |&#xD;
// | Unused when parameter CLOCKING_MODE is "common_clock".                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data input for port A write operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | douta          | Output    | READ_DATA_WIDTH_A                     | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port A read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | doutb          | Output    | READ_DATA_WIDTH_B                     | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port B read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | enb            | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port B.                                                                                    |&#xD;
// | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regcea         | Input     | 1                                     | clka    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock Enable for the last register stage on the output data path.                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regceb         | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rsta           | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port A output register stage.                                                            |&#xD;
// | Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rstb           | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port B output register stage.                                                            |&#xD;
// | Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wea            | Input     | WRITE_DATA_WIDTH_A                    | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |&#xD;
// | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |&#xD;
// | For example, to synchronously write only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
xpm_memory_dpdistram #(&#xD;
.ADDR_WIDTH_A(6),               // DECIMAL&#xD;
.ADDR_WIDTH_B(6),               // DECIMAL&#xD;
.BYTE_WRITE_WIDTH_A(32),        // DECIMAL&#xD;
.CLOCKING_MODE("common_clock"), // String&#xD;
.MEMORY_INIT_FILE("none"),      // String&#xD;
.MEMORY_INIT_PARAM("0"),        // String&#xD;
.MEMORY_OPTIMIZATION("true"),   // String&#xD;
.MEMORY_SIZE(2048),             // DECIMAL&#xD;
.MESSAGE_CONTROL(0),            // DECIMAL&#xD;
.READ_DATA_WIDTH_A(32),         // DECIMAL&#xD;
.READ_DATA_WIDTH_B(32),         // DECIMAL&#xD;
.READ_LATENCY_A(2),             // DECIMAL&#xD;
.READ_LATENCY_B(2),             // DECIMAL&#xD;
.READ_RESET_VALUE_A("0"),       // String&#xD;
.READ_RESET_VALUE_B("0"),       // String&#xD;
.USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL&#xD;
.USE_MEM_INIT(1),               // DECIMAL&#xD;
.WRITE_DATA_WIDTH_A(32)         // DECIMAL&#xD;
)&#xD;
xpm_memory_dpdistram_inst (&#xD;
.douta(douta),   // READ_DATA_WIDTH_A-bit output: Data output for port A read operations.&#xD;
.doutb(doutb),   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.&#xD;
.addra(addra),   // ADDR_WIDTH_A-bit input: Address for port A write and read operations.&#xD;
.addrb(addrb),   // ADDR_WIDTH_B-bit input: Address for port B write and read operations.&#xD;
.clka(clka),     // 1-bit input: Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE&#xD;
// is "common_clock".&#xD;
&#xD;
.clkb(clkb),     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is&#xD;
// "independent_clock". Unused when parameter CLOCKING_MODE is "common_clock".&#xD;
&#xD;
.dina(dina),     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.&#xD;
.ena(ena),       // 1-bit input: Memory enable signal for port A. Must be high on clock cycles when read&#xD;
// or write operations are initiated. Pipelined internally.&#xD;
&#xD;
.enb(enb),       // 1-bit input: Memory enable signal for port B. Must be high on clock cycles when read&#xD;
// or write operations are initiated. Pipelined internally.&#xD;
&#xD;
.regcea(regcea), // 1-bit input: Clock Enable for the last register stage on the output data path.&#xD;
.regceb(regceb), // 1-bit input: Do not change from the provided value.&#xD;
.rsta(rsta),     // 1-bit input: Reset signal for the final port A output register stage. Synchronously&#xD;
// resets output port douta to the value specified by parameter READ_RESET_VALUE_A.&#xD;
&#xD;
.rstb(rstb),     // 1-bit input: Reset signal for the final port B output register stage. Synchronously&#xD;
// resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.&#xD;
&#xD;
.wea(wea)        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input data port dina. 1&#xD;
// bit wide when word-wide writes are used. In byte-wide write configurations, each bit&#xD;
// controls the writing one byte of dina to address addra. For example, to synchronously&#xD;
// write only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.&#xD;
&#xD;
);</Template><Template Name="xpm_mem_dprom" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_B         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B address port addrb, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port B, i.e. = $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | AUTO_SLEEP_TIME      | Integer            | Range: 0 - 15. Default value = 0.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Must be set to 0                                                                                                    |&#xD;
// | 0 - Disable auto-sleep feature                                                                                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | CLOCKING_MODE        | String             | Allowed values: common_clock, independent_clock. Default value = common_clock.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate whether port A and port B are clocked with a common clock or with independent clocks-                     |&#xD;
// | "common_clock"- Common clocking; clock both port A and port B with clka                                             |&#xD;
// | "independent_clock"- Independent clocking; clock port A with clka and port B with clkb                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, both_encode_and_decode, decode_only, encode_only. Default value = no_ecc.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory. See the Memory File (MEM) section for more                        |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                           | |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory. For example, if the narrowest data width is 8, and the depth of   |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | |                   |                                                                                               |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_PRIMITIVE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the memory primitive (resource type) to use-                                                              |&#xD;
// | "auto"- Allow Vivado Synthesis to choose                                                                            |&#xD;
// | "distributed"- Distributed memory                                                                                   |&#xD;
// | "block"- Block memory                                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 ROM.                                                                           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_A    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A read data output port douta, in bits.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_B    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B read data output port doutb, in bits.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_A       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |&#xD;
// | number of clka cycles.                                                                                              |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_B       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |&#xD;
// | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_A   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |&#xD;
// | For example, to reset the value of port douta to all 0s when READ_DATA_WIDTH_A is 32, specify 32HHHHh0.             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_B   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | String             | Allowed values: disable_sleep, use_sleep_pin. Default value = disable_sleep.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |&#xD;
// | dynamic power saving option                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A read operations.                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addrb          | Input     | ADDR_WIDTH_B                          | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port B read operations.                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clkb           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |&#xD;
// | Unused when parameter CLOCKING_MODE is "common_clock".                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterrb       | Output    | 1                                     | clkb    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | douta          | Output    | READ_DATA_WIDTH_A                     | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port A read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | doutb          | Output    | READ_DATA_WIDTH_B                     | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port B read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | enb            | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port B.                                                                                    |&#xD;
// | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterrb | Input     | 1                                     | clkb    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterrb | Input     | 1                                     | clkb    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regcea         | Input     | 1                                     | clka    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regceb         | Input     | 1                                     | clkb    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rsta           | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port A output register stage.                                                            |&#xD;
// | Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rstb           | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port B output register stage.                                                            |&#xD;
// | Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterrb       | Output    | 1                                     | clkb    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | sleep signal to enable the dynamic power saving feature.                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
xpm_memory_dprom #(&#xD;
.ADDR_WIDTH_A(6),               // DECIMAL&#xD;
.ADDR_WIDTH_B(6),               // DECIMAL&#xD;
.AUTO_SLEEP_TIME(0),            // DECIMAL&#xD;
.CLOCKING_MODE("common_clock"), // String&#xD;
.ECC_MODE("no_ecc"),            // String&#xD;
.MEMORY_INIT_FILE("none"),      // String&#xD;
.MEMORY_INIT_PARAM("0"),        // String&#xD;
.MEMORY_OPTIMIZATION("true"),   // String&#xD;
.MEMORY_PRIMITIVE("auto"),      // String&#xD;
.MEMORY_SIZE(2048),             // DECIMAL&#xD;
.MESSAGE_CONTROL(0),            // DECIMAL&#xD;
.READ_DATA_WIDTH_A(32),         // DECIMAL&#xD;
.READ_DATA_WIDTH_B(32),         // DECIMAL&#xD;
.READ_LATENCY_A(2),             // DECIMAL&#xD;
.READ_LATENCY_B(2),             // DECIMAL&#xD;
.READ_RESET_VALUE_A("0"),       // String&#xD;
.READ_RESET_VALUE_B("0"),       // String&#xD;
.USE_MEM_INIT(1),               // DECIMAL&#xD;
.WAKEUP_TIME("disable_sleep")   // String&#xD;
)&#xD;
xpm_memory_dprom_inst (&#xD;
.dbiterra(dbiterra),             // 1-bit output: Leave open.&#xD;
.dbiterrb(dbiterrb),             // 1-bit output: Leave open.&#xD;
.douta(douta),                   // READ_DATA_WIDTH_A-bit output: Data output for port A read operations.&#xD;
.doutb(doutb),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.&#xD;
.sbiterra(sbiterra),             // 1-bit output: Leave open.&#xD;
.sbiterrb(sbiterrb),             // 1-bit output: Leave open.&#xD;
.addra(addra),                   // ADDR_WIDTH_A-bit input: Address for port A read operations.&#xD;
.addrb(addrb),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.&#xD;
.clka(clka),                     // 1-bit input: Clock signal for port A. Also clocks port B when&#xD;
// parameter CLOCKING_MODE is "common_clock".&#xD;
&#xD;
.clkb(clkb),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is&#xD;
// "independent_clock". Unused when parameter CLOCKING_MODE is&#xD;
// "common_clock".&#xD;
&#xD;
.ena(ena),                       // 1-bit input: Memory enable signal for port A. Must be high on clock&#xD;
// cycles when read operations are initiated. Pipelined internally.&#xD;
&#xD;
.enb(enb),                       // 1-bit input: Memory enable signal for port B. Must be high on clock&#xD;
// cycles when read operations are initiated. Pipelined internally.&#xD;
&#xD;
.injectdbiterra(injectdbiterra), // 1-bit input: Do not change from the provided value.&#xD;
.injectdbiterrb(injectdbiterrb), // 1-bit input: Do not change from the provided value.&#xD;
.injectsbiterra(injectsbiterra), // 1-bit input: Do not change from the provided value.&#xD;
.injectsbiterrb(injectsbiterrb), // 1-bit input: Do not change from the provided value.&#xD;
.regcea(regcea),                 // 1-bit input: Do not change from the provided value.&#xD;
.regceb(regceb),                 // 1-bit input: Do not change from the provided value.&#xD;
.rsta(rsta),                     // 1-bit input: Reset signal for the final port A output register stage.&#xD;
// Synchronously resets output port douta to the value specified by&#xD;
// parameter READ_RESET_VALUE_A.&#xD;
&#xD;
.rstb(rstb),                     // 1-bit input: Reset signal for the final port B output register stage.&#xD;
// Synchronously resets output port doutb to the value specified by&#xD;
// parameter READ_RESET_VALUE_B.&#xD;
&#xD;
.sleep(sleep)                    // 1-bit input: sleep signal to enable the dynamic power saving feature.&#xD;
);</Template><Template Name="xpm_mem_sdpram" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A).        |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_B         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B address port addrb, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port B, i.e. = $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | AUTO_SLEEP_TIME      | Integer            | Range: 0 - 15. Default value = 0.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Number of clk[a|b] cycles to auto-sleep, if feature is available in architecture                                    |&#xD;
// |                                                                                                                     |&#xD;
// |  0 - Disable auto-sleep feature                                                                                     |&#xD;
// |   3-15 - Number of auto-sleep latency cycles                                                                        |&#xD;
// |                                                                                                                     |&#xD;
// | Do not change from the value provided in the template instantiation                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | BYTE_WRITE_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | To enable byte-wide writes on port A, specify the byte width, in bits-                                              |&#xD;
// |                                                                                                                     |&#xD;
// |  8- 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                               |&#xD;
// |   9- 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |&#xD;
// |                                                                                                                     |&#xD;
// | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | CLOCKING_MODE        | String             | Allowed values: common_clock, independent_clock. Default value = common_clock.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate whether port A and port B are clocked with a common clock or with independent clocks-                     |&#xD;
// |                                                                                                                     |&#xD;
// |  "common_clock"- Common clocking; clock both port A and port B with clka                                            |&#xD;
// |   "independent_clock"- Independent clocking; clock port A with clka and port B with clkb                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, both_encode_and_decode, decode_only, encode_only. Default value = no_ecc.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory. See the Memory File (MEM) section for more                        |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                             |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory. For example, if the narrowest data width is 8, and the depth of   |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | |                   |                                                                                               |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_PRIMITIVE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the memory primitive (resource type) to use-                                                              |&#xD;
// |                                                                                                                     |&#xD;
// |  "auto"- Allow Vivado Synthesis to choose                                                                           |&#xD;
// |   "distributed"- Distributed memory                                                                                 |&#xD;
// |   "block"- Block memory                                                                                             |&#xD;
// |   "ultra"- Ultra RAM memory                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 RAM.                                                                           |&#xD;
// |                                                                                                                     |&#xD;
// |  When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_B        |&#xD;
// |   When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A      |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_B    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B read data output port doutb, in bits.                                               |&#xD;
// |                                                                                                                     |&#xD;
// |  When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                |&#xD;
// |   When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be        |&#xD;
// | multiples of 64-bits                                                                                                |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_B       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |&#xD;
// | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output. |&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_B   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |&#xD;
// | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |&#xD;
// | If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |&#xD;
// | When ECC is enabled, then reset value is not supported.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_EMBEDDED_CONSTRAINT| Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the set_false_path constraint addition between clka of Distributed RAM and doutb_reg on clkb    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | String             | Allowed values: disable_sleep, use_sleep_pin. Default value = disable_sleep.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |&#xD;
// | dynamic power saving option                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | multiples of 64-bits                                                                                                |&#xD;
// | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_MODE_B         | String             | Allowed values: no_change, read_first, write_first. Default value = no_change.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write mode behavior for port B output data port, doutb.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A write operations.                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addrb          | Input     | ADDR_WIDTH_B                          | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port B read operations.                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clkb           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |&#xD;
// | Unused when parameter CLOCKING_MODE is "common_clock".                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterrb       | Output    | 1                                     | clkb    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate double bit error occurrence on the data output of port B.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data input for port A write operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | doutb          | Output    | READ_DATA_WIDTH_B                     | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port B read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when write operations are initiated. Pipelined internally.                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | enb            | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port B.                                                                                    |&#xD;
// | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regceb         | Input     | 1                                     | clkb    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock Enable for the last register stage on the output data path.                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rstb           | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port B output register stage.                                                            |&#xD;
// | Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterrb       | Output    | 1                                     | clkb    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate single bit error occurrence on the data output of port B.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | sleep signal to enable the dynamic power saving feature.                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wea            | Input     | WRITE_DATA_WIDTH_A                    | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |&#xD;
// | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |&#xD;
// | For example, to synchronously write only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
xpm_memory_sdpram #(&#xD;
.ADDR_WIDTH_A(6),               // DECIMAL&#xD;
.ADDR_WIDTH_B(6),               // DECIMAL&#xD;
.AUTO_SLEEP_TIME(0),            // DECIMAL&#xD;
.BYTE_WRITE_WIDTH_A(32),        // DECIMAL&#xD;
.CLOCKING_MODE("common_clock"), // String&#xD;
.ECC_MODE("no_ecc"),            // String&#xD;
.MEMORY_INIT_FILE("none"),      // String&#xD;
.MEMORY_INIT_PARAM("0"),        // String&#xD;
.MEMORY_OPTIMIZATION("true"),   // String&#xD;
.MEMORY_PRIMITIVE("auto"),      // String&#xD;
.MEMORY_SIZE(2048),             // DECIMAL&#xD;
.MESSAGE_CONTROL(0),            // DECIMAL&#xD;
.READ_DATA_WIDTH_B(32),         // DECIMAL&#xD;
.READ_LATENCY_B(2),             // DECIMAL&#xD;
.READ_RESET_VALUE_B("0"),       // String&#xD;
.USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL&#xD;
.USE_MEM_INIT(1),               // DECIMAL&#xD;
.WAKEUP_TIME("disable_sleep"),  // String&#xD;
.WRITE_DATA_WIDTH_A(32),        // DECIMAL&#xD;
.WRITE_MODE_B("no_change")      // String&#xD;
)&#xD;
xpm_memory_sdpram_inst (&#xD;
.dbiterrb(dbiterrb),             // 1-bit output: Status signal to indicate double bit error occurrence&#xD;
// on the data output of port B.&#xD;
&#xD;
.doutb(doutb),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.&#xD;
.sbiterrb(sbiterrb),             // 1-bit output: Status signal to indicate single bit error occurrence&#xD;
// on the data output of port B.&#xD;
&#xD;
.addra(addra),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.&#xD;
.addrb(addrb),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.&#xD;
.clka(clka),                     // 1-bit input: Clock signal for port A. Also clocks port B when&#xD;
// parameter CLOCKING_MODE is "common_clock".&#xD;
&#xD;
.clkb(clkb),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is&#xD;
// "independent_clock". Unused when parameter CLOCKING_MODE is&#xD;
// "common_clock".&#xD;
&#xD;
.dina(dina),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.&#xD;
.ena(ena),                       // 1-bit input: Memory enable signal for port A. Must be high on clock&#xD;
// cycles when write operations are initiated. Pipelined internally.&#xD;
&#xD;
.enb(enb),                       // 1-bit input: Memory enable signal for port B. Must be high on clock&#xD;
// cycles when read operations are initiated. Pipelined internally.&#xD;
&#xD;
.injectdbiterra(injectdbiterra), // 1-bit input: Controls double bit error injection on input data when&#xD;
// ECC enabled (Error injection capability is not available in&#xD;
// "decode_only" mode).&#xD;
&#xD;
.injectsbiterra(injectsbiterra), // 1-bit input: Controls single bit error injection on input data when&#xD;
// ECC enabled (Error injection capability is not available in&#xD;
// "decode_only" mode).&#xD;
&#xD;
.regceb(regceb),                 // 1-bit input: Clock Enable for the last register stage on the output&#xD;
// data path.&#xD;
&#xD;
.rstb(rstb),                     // 1-bit input: Reset signal for the final port B output register stage.&#xD;
// Synchronously resets output port doutb to the value specified by&#xD;
// parameter READ_RESET_VALUE_B.&#xD;
&#xD;
.sleep(sleep),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.&#xD;
.wea(wea)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input&#xD;
// data port dina. 1 bit wide when word-wide writes are used. In&#xD;
// byte-wide write configurations, each bit controls the writing one&#xD;
// byte of dina to address addra. For example, to synchronously write&#xD;
// only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be&#xD;
// 4'b0010.&#xD;
&#xD;
);</Template><Template Name="xpm_mem_spram" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A). |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | AUTO_SLEEP_TIME      | Integer            | Range: 0 - 15. Default value = 0.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Number of clka cycles to auto-sleep, if feature is available in architecture                                        |&#xD;
// | 0 - Disable auto-sleep feature                                                                                      |&#xD;
// | 3-15 - Number of auto-sleep latency cycles                                                                          |&#xD;
// | Do not change from the value provided in the template instantiation                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | BYTE_WRITE_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | To enable byte-wide writes on port A, specify the byte width, in bits-                                              |&#xD;
// | 8- 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                                |&#xD;
// | 9- 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                                |&#xD;
// | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, both_encode_and_decode, decode_only, encode_only. Default value = no_ecc.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory. See the Memory File (MEM) section for more                        |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                             |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory. For example, if the narrowest data width is 8, and the depth of   |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | |                   |                                                                                               |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_PRIMITIVE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the memory primitive (resource type) to use-                                                              |&#xD;
// |                                                                                                                     |&#xD;
// |  "auto"- Allow Vivado Synthesis to choose                                                                           |&#xD;
// |   "distributed"- Distributed memory                                                                                 |&#xD;
// |   "block"- Block memory                                                                                             |&#xD;
// |   "ultra"- Ultra RAM memory                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 RAM.                                                                           |&#xD;
// |                                                                                                                     |&#xD;
// |  When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_A        |&#xD;
// |   When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A      |&#xD;
// | .                                                                                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_A    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A read data output port douta, in bits.                                               |&#xD;
// | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |&#xD;
// | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |&#xD;
// | multiples of 64-bits.                                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_A       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |&#xD;
// | number of clka cycles.                                                                                              |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_A   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |&#xD;
// | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |&#xD;
// | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |&#xD;
// | When ECC is enabled, then reset value is not supported.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | String             | Allowed values: disable_sleep, use_sleep_pin. Default value = disable_sleep.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |&#xD;
// | dynamic power saving option                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A write data input port dina, in bits.                                                |&#xD;
// | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |&#xD;
// | multiples of 64-bits                                                                                                |&#xD;
// | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits.               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_MODE_A         | String             | Allowed values: read_first, no_change, write_first. Default value = read_first.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write mode behavior for port A output data port, douta.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A write and read operations.                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A.                                                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate double bit error occurrence on the data output of port A.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data input for port A write operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | douta          | Output    | READ_DATA_WIDTH_A                     | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port A read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regcea         | Input     | 1                                     | clka    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock Enable for the last register stage on the output data path.                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rsta           | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port A output register stage.                                                            |&#xD;
// | Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate single bit error occurrence on the data output of port A.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | sleep signal to enable the dynamic power saving feature.                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | wea            | Input     | WRITE_DATA_WIDTH_A                    | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |&#xD;
// | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |&#xD;
// | For example, to synchronously write only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
   xpm_memory_spram #(&#xD;
      .ADDR_WIDTH_A(6),              // DECIMAL&#xD;
      .AUTO_SLEEP_TIME(0),           // DECIMAL&#xD;
      .BYTE_WRITE_WIDTH_A(32),       // DECIMAL&#xD;
      .ECC_MODE("no_ecc"),           // String&#xD;
      .MEMORY_INIT_FILE("none"),     // String&#xD;
      .MEMORY_INIT_PARAM("0"),       // String&#xD;
      .MEMORY_OPTIMIZATION("true"),  // String&#xD;
      .MEMORY_PRIMITIVE("auto"),     // String&#xD;
      .MEMORY_SIZE(2048),            // DECIMAL&#xD;
      .MESSAGE_CONTROL(0),           // DECIMAL&#xD;
      .READ_DATA_WIDTH_A(32),        // DECIMAL&#xD;
      .READ_LATENCY_A(2),            // DECIMAL&#xD;
      .READ_RESET_VALUE_A("0"),      // String&#xD;
      .USE_MEM_INIT(1),              // DECIMAL&#xD;
      .WAKEUP_TIME("disable_sleep"), // String&#xD;
      .WRITE_DATA_WIDTH_A(32),       // DECIMAL&#xD;
      .WRITE_MODE_A("read_first")    // String&#xD;
   )&#xD;
   xpm_memory_spram_inst (&#xD;
      .dbiterra(dbiterra),             // 1-bit output: Status signal to indicate double bit error occurrence&#xD;
                                       // on the data output of port A.&#xD;
&#xD;
      .douta(douta),                   // READ_DATA_WIDTH_A-bit output: Data output for port A read operations.&#xD;
      .sbiterra(sbiterra),             // 1-bit output: Status signal to indicate single bit error occurrence&#xD;
                                       // on the data output of port A.&#xD;
&#xD;
      .addra(addra),                   // ADDR_WIDTH_A-bit input: Address for port A write and read operations.&#xD;
      .clka(clka),                     // 1-bit input: Clock signal for port A.&#xD;
      .dina(dina),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.&#xD;
      .ena(ena),                       // 1-bit input: Memory enable signal for port A. Must be high on clock&#xD;
                                       // cycles when read or write operations are initiated. Pipelined&#xD;
                                       // internally.&#xD;
&#xD;
      .injectdbiterra(injectdbiterra), // 1-bit input: Controls double bit error injection on input data when&#xD;
                                       // ECC enabled (Error injection capability is not available in&#xD;
                                       // "decode_only" mode).&#xD;
&#xD;
      .injectsbiterra(injectsbiterra), // 1-bit input: Controls single bit error injection on input data when&#xD;
                                       // ECC enabled (Error injection capability is not available in&#xD;
                                       // "decode_only" mode).&#xD;
&#xD;
      .regcea(regcea),                 // 1-bit input: Clock Enable for the last register stage on the output&#xD;
                                       // data path.&#xD;
&#xD;
      .rsta(rsta),                     // 1-bit input: Reset signal for the final port A output register stage.&#xD;
                                       // Synchronously resets output port douta to the value specified by&#xD;
                                       // parameter READ_RESET_VALUE_A.&#xD;
&#xD;
      .sleep(sleep),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.&#xD;
      .wea(wea)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input&#xD;
                                       // data port dina. 1 bit wide when word-wide writes are used. In&#xD;
                                       // byte-wide write configurations, each bit controls the writing one&#xD;
                                       // byte of dina to address addra. For example, to synchronously write&#xD;
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be&#xD;
                                       // 4'b0010.&#xD;
&#xD;
   );</Template><Template Name="xpm_mem_sprom" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | AUTO_SLEEP_TIME      | Integer            | Range: 0 - 15. Default value = 0.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Must be set to 0                                                                                                    |&#xD;
// | 0 - Disable auto-sleep feature                                                                                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, both_encode_and_decode, decode_only, encode_only. Default value = no_ecc.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Must be "no_ecc". ECC with Initialization is currently not supported.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory. See the Memory File (MEM) section for more                        |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                             |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory. For example, if the narrowest data width is 8, and the depth of   |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | |                   |                                                                                               |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_PRIMITIVE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the memory primitive (resource type) to use-                                                              |&#xD;
// | "auto"- Allow Vivado Synthesis to choose                                                                            |&#xD;
// | "distributed"- Distributed memory                                                                                   |&#xD;
// | "block"- Block memory                                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 ROM.                                                                           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_A    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A read data output port douta, in bits.                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_A       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |&#xD;
// | number of clka cycles.                                                                                              |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_A   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |&#xD;
// | For example, to reset the value of port douta to all 0s when READ_DATA_WIDTH_A is 32, specify 32HHHHh0.             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | String             | Allowed values: disable_sleep, use_sleep_pin. Default value = disable_sleep.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |&#xD;
// | dynamic power saving option                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A read operations.                                                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A.                                                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | douta          | Output    | READ_DATA_WIDTH_A                     | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port A read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regcea         | Input     | 1                                     | clka    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Do not change from the provided value.                                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rsta           | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Reset signal for the final port A output register stage.                                                            |&#xD;
// | Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Leave open.                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | sleep          | Input     | 1                                     | *       | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | sleep signal to enable the dynamic power saving feature.                                                            |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
xpm_memory_sprom #(&#xD;
.ADDR_WIDTH_A(6),              // DECIMAL&#xD;
.AUTO_SLEEP_TIME(0),           // DECIMAL&#xD;
.ECC_MODE("no_ecc"),           // String&#xD;
.MEMORY_INIT_FILE("none"),     // String&#xD;
.MEMORY_INIT_PARAM("0"),       // String&#xD;
.MEMORY_OPTIMIZATION("true"),  // String&#xD;
.MEMORY_PRIMITIVE("auto"),     // String&#xD;
.MEMORY_SIZE(2048),            // DECIMAL&#xD;
.MESSAGE_CONTROL(0),           // DECIMAL&#xD;
.READ_DATA_WIDTH_A(32),        // DECIMAL&#xD;
.READ_LATENCY_A(2),            // DECIMAL&#xD;
.READ_RESET_VALUE_A("0"),      // String&#xD;
.USE_MEM_INIT(1),              // DECIMAL&#xD;
.WAKEUP_TIME("disable_sleep")  // String&#xD;
)&#xD;
xpm_memory_sprom_inst (&#xD;
.dbiterra(dbiterra),             // 1-bit output: Leave open.&#xD;
.douta(douta),                   // READ_DATA_WIDTH_A-bit output: Data output for port A read operations.&#xD;
.sbiterra(sbiterra),             // 1-bit output: Leave open.&#xD;
.addra(addra),                   // ADDR_WIDTH_A-bit input: Address for port A read operations.&#xD;
.clka(clka),                     // 1-bit input: Clock signal for port A.&#xD;
.ena(ena),                       // 1-bit input: Memory enable signal for port A. Must be high on clock&#xD;
// cycles when read operations are initiated. Pipelined internally.&#xD;
&#xD;
.injectdbiterra(injectdbiterra), // 1-bit input: Do not change from the provided value.&#xD;
.injectsbiterra(injectsbiterra), // 1-bit input: Do not change from the provided value.&#xD;
.regcea(regcea),                 // 1-bit input: Do not change from the provided value.&#xD;
.rsta(rsta),                     // 1-bit input: Reset signal for the final port A output register stage.&#xD;
// Synchronously resets output port douta to the value specified by&#xD;
// parameter READ_RESET_VALUE_A.&#xD;
&#xD;
.sleep(sleep)                    // 1-bit input: sleep signal to enable the dynamic power saving feature.&#xD;
);&#xD;
&#xD;
// End of xpm_memory_sprom_inst instantiation&#xD;
</Template><Template Name="xpm_mem_tdpram" Description="" Comments="0" Strings="0">&#xD;
// Parameter usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Parameter name       | Data type          | Restrictions, if applicable                                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_A         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A address port addra, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port A, i.e. = $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A). |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ADDR_WIDTH_B         | Integer            | Range: 1 - 20. Default value = 6.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B address port addrb, in bits.                                                        |&#xD;
// | Must be large enough to access the entire memory from port B, i.e. = $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B). |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | AUTO_SLEEP_TIME      | Integer            | Range: 0 - 15. Default value = 0.                                       |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Number of clk[a|b] cycles to auto-sleep, if feature is available in architecture                                    |&#xD;
// | 0 - Disable auto-sleep feature                                                                                      |&#xD;
// | 3-15 - Number of auto-sleep latency cycles                                                                          |&#xD;
// | Do not change from the value provided in the template instantiation                                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | BYTE_WRITE_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | To enable byte-wide writes on port A, specify the byte width, in bits-                                              |&#xD;
// | 8- 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                                |&#xD;
// | 9- 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                                |&#xD;
// | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | BYTE_WRITE_WIDTH_B   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | To enable byte-wide writes on port B, specify the byte width, in bits-                                              |&#xD;
// | 8- 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 8                                |&#xD;
// | 9- 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 9                                |&#xD;
// | Or to enable word-wide writes on port B, specify the same value as for WRITE_DATA_WIDTH_B.                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | CLOCKING_MODE        | String             | Allowed values: common_clock, independent_clock. Default value = common_clock.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate whether port A and port B are clocked with a common clock or with independent clocks-                     |&#xD;
// | "common_clock"- Common clocking; clock both port A and port B with clka                                             |&#xD;
// | "independent_clock"- Independent clocking; clock port A with clka and port B with clkb                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ECC_MODE             | String             | Allowed values: no_ecc, both_encode_and_decode, decode_only, encode_only. Default value = no_ecc.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | PublishToDocs: Yes                                                                                                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_FILE     | String             | Default value = none.                                                   |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file-|&#xD;
// | Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").        |&#xD;
// | File format must be ASCII and consist of only hexadecimal values organized into the specified depth by              |&#xD;
// | narrowest data width generic value of the memory. See the Memory File (MEM) section for more                        |&#xD;
// | information on the syntax. Initialization of memory happens through the file name specified only when parameter     |&#xD;
// | MEMORY_INIT_PARAM value is equal to "".                                                                           | |&#xD;
// | When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_INIT_PARAM    | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |&#xD;
// | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |&#xD;
// | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |&#xD;
// | narrowest data width generic value of the memory. For example, if the narrowest data width is 8, and the depth of   |&#xD;
// | memory is 8 locations, then the parameter value should be passed as shown below.                                    |&#xD;
// | parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                               |&#xD;
// | |                   |                                                                                               |&#xD;
// | 0th                7th                                                                                              |&#xD;
// | location            location.                                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_OPTIMIZATION  | String             | Allowed values: true, false. Default value = true.                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "true" to enable the optimization of unused memory or bits in the memory structure. Specify "false" to      |&#xD;
// | disable the optimization of unused memory or bits in the memory structure.                                          |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_PRIMITIVE     | String             | Allowed values: auto, block, distributed, ultra. Default value = auto.  |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Designate the memory primitive (resource type) to use-                                                              |&#xD;
// | "auto"- Allow Vivado Synthesis to choose                                                                            |&#xD;
// | "distributed"- Distributed memory                                                                                   |&#xD;
// | "block"- Block memory                                                                                               |&#xD;
// | "ultra"- Ultra RAM memory                                                                                           |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MEMORY_SIZE          | Integer            | Range: 2 - 150994944. Default value = 2048.                             |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the total memory array size, in bits.                                                                       |&#xD;
// | For example, enter 65536 for a 2kx32 RAM.                                                                           |&#xD;
// | When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_[A|B]     |&#xD;
// | When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_[A|B].   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | MESSAGE_CONTROL      | Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_A    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A read data output port douta, in bits.                                               |&#xD;
// | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |&#xD;
// | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |&#xD;
// | multiples of 64-bits.                                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_DATA_WIDTH_B    | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B read data output port doutb, in bits.                                               |&#xD;
// | The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                 |&#xD;
// | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be          |&#xD;
// | multiples of 64-bits.                                                                                               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_A       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |&#xD;
// | number of clka cycles.                                                                                              |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_LATENCY_B       | Integer            | Range: 0 - 100. Default value = 2.                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |&#xD;
// | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |&#xD;
// | To target block memory, a value of 1 or larger is required- 1 causes use of memory latch only; 2 causes use of      |&#xD;
// | output register. To target distributed memory, a value of 0 or larger is required- 0 indicates combinatorial output.|&#xD;
// | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_A   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |&#xD;
// | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |&#xD;
// | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |&#xD;
// | When ECC is enabled, then reset value is not supported.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | READ_RESET_VALUE_B   | String             | Default value = 0.                                                      |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |&#xD;
// | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |&#xD;
// | If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |&#xD;
// | When ECC is enabled, then reset value is not supported.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_EMBEDDED_CONSTRAINT| Integer            | Range: 0 - 1. Default value = 0.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the set_false_path constraint addition between clka of Distributed RAM and doutb_reg on clkb    |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | USE_MEM_INIT         | Integer            | Range: 0 - 1. Default value = 1.                                        |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |&#xD;
// | Note- This message gets generated only when there is no Memory Initialization specified either through file or      |&#xD;
// | Parameter.                                                                                                          |&#xD;
// | INFO - MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                          |&#xD;
// | Initial memory contents will be all 0s.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WAKEUP_TIME          | String             | Allowed values: disable_sleep, use_sleep_pin. Default value = disable_sleep.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |&#xD;
// | dynamic power saving option                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH_A   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port A write data input port dina, in bits.                                                |&#xD;
// | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |&#xD;
// | multiples of 64-bits                                                                                                |&#xD;
// | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits.               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_DATA_WIDTH_B   | Integer            | Range: 1 - 4608. Default value = 32.                                    |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Specify the width of the port B write data input port dinb, in bits.                                                |&#xD;
// | The values of WRITE_DATA_WIDTH_B and READ_DATA_WIDTH_B must be equal.                                               |&#xD;
// | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_B has to be         |&#xD;
// | multiples of 64-bits                                                                                                |&#xD;
// | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_B has to be multiples of 72-bits.               |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_MODE_A         | String             | Allowed values: no_change, read_first, write_first. Default value = no_change.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write mode behavior for port A output data port, douta.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | WRITE_MODE_B         | String             | Allowed values: no_change, read_first, write_first. Default value = no_change.|&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Write mode behavior for port B output data port, doutb.                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
&#xD;
// Port usage table, organized as follows:&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | Port name      | Direction | Size, in bits                         | Domain  | Sense       | Handling if unused     |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Description                                                                                                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addra          | Input     | ADDR_WIDTH_A                          | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port A write and read operations.                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | addrb          | Input     | ADDR_WIDTH_B                          | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Address for port B write and read operations.                                                                       |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clka           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | clkb           | Input     | 1                                     | *       | Rising edge | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |&#xD;
// | Unused when parameter CLOCKING_MODE is "common_clock".                                                              |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterra       | Output    | 1                                     | clka    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate double bit error occurrence on the data output of port A.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dbiterrb       | Output    | 1                                     | clkb    | Active-high | DoNotCare              |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Status signal to indicate double bit error occurrence on the data output of port A.                                 |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data input for port A write operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | dinb           | Input     | WRITE_DATA_WIDTH_B                    | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data input for port B write operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | douta          | Output    | READ_DATA_WIDTH_A                     | clka    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port A read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | doutb          | Output    | READ_DATA_WIDTH_B                     | clkb    |             | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Data output for port B read operations.                                                                             |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | ena            | Input     | 1                                     | clka    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port A.                                                                                    |&#xD;
// | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | enb            | Input     | 1                                     | clkb    | Active-high | Required               |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Memory enable signal for port B.                                                                                    |&#xD;
// | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectdbiterrb | Input     | 1                                     | clkb    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterra | Input     | 1                                     | clka    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | injectsbiterrb | Input     | 1                                     | clkb    | Active-high | Tie to 1'b0            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |&#xD;
// | "decode_only" mode).                                                                                                |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regcea         | Input     | 1                                     | clka    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock Enable for the last register stage on the output data path.                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | regceb         | Input     | 1                                     | clkb    | Active-high | Tie to 1'b1            |&#xD;
// |---------------------------------------------------------------------------------------------------------------------|&#xD;
// | Clock Enable for the last register stage on the output data path.                                                   |&#xD;
// +---------------------------------------------------------------------------------------------------------------------+&#xD;
// | rsta           | Input   </Template><Template Name="fsm" Description="" Comments="0" Strings="0">&#xD;
//FSM Parameter Define&#xD;
parameter	S_IDLE		= 2'd0;&#xD;
parameter	S_S1		= 2'd1;&#xD;
parameter	S_S2		= 2'd2;&#xD;
parameter	S_S3		= 2'd3;&#xD;
&#xD;
reg		[1:0]	current_state	= S_IDLE;&#xD;
reg		[1:0]	next_state		= S_IDLE;&#xD;
&#xD;
//FSM for sim&#xD;
// synthesis translate_off&#xD;
reg		[127:0]			state_ascii;&#xD;
always @ ( * ) begin&#xD;
	case(current_state)&#xD;
		2'd0 	:	state_ascii	= "S_IDLE";&#xD;
		2'd1 	:	state_ascii	= "S_1";&#xD;
		2'd2 	:	state_ascii	= "S_2";&#xD;
		2'd3 	:	state_ascii	= "S_3";&#xD;
		default	:	state_ascii	= "ERROR";&#xD;
	endcase&#xD;
end&#xD;
// synthesis translate_on&#xD;
&#xD;
//	===============================================================================================&#xD;
//	ref ***FSM***&#xD;
//	===============================================================================================&#xD;
//	-------------------------------------------------------------------------------------&#xD;
//	FSM Sequential Logic&#xD;
//	-------------------------------------------------------------------------------------&#xD;
always @ (posedge clk) begin&#xD;
	if(reset) begin&#xD;
		current_state	&lt;= S_IDLE;&#xD;
	end&#xD;
	else begin&#xD;
		current_state	&lt;= next_state;&#xD;
	end&#xD;
end&#xD;
&#xD;
//	-------------------------------------------------------------------------------------&#xD;
//	FSM Conbinatial Logic&#xD;
//	-------------------------------------------------------------------------------------&#xD;
always @ ( * ) begin&#xD;
	case(current_state)&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		//	IDLE&#x72B6;&#x6001;&#x8BF4;&#x660E;&#xD;
		//	S_IDLE -&gt; S_S1&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	S_IDLE -&gt; S_S2&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		S_IDLE	:&#xD;
			next_state	= S_S1;&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		//	S1&#x72B6;&#x6001;&#x8BF4;&#x660E;&#xD;
		//	S_S1 -&gt; S_S2&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	S_S1 -&gt; S_S3&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		S_S1	:&#xD;
			next_state	= S_S2;&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		//	S2&#x72B6;&#x6001;&#x8BF4;&#x660E;&#xD;
		//	S_S2 -&gt; S_S3&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	S_S2 -&gt; S_IDLE&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		S_S2	:&#xD;
			next_state	= S_S3;&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		//	S3&#x72B6;&#x6001;&#x8BF4;&#x660E;&#xD;
		//	S_S3 -&gt; S_S2&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	S_S3 -&gt; S_IDLE&#xD;
		//	1.&#x6761;&#x4EF6;1 2.&#x6761;&#x4EF6;2 3.&#x6761;&#x4EF6;3&#xD;
		//	-------------------------------------------------------------------------------------&#xD;
		S_S3	:&#xD;
			next_state	= S_IDLE;&#xD;
		default	:&#xD;
			next_state	= S_IDLE;&#xD;
	endcase&#xD;
end&#xD;
&#xD;
//	-------------------------------------------------------------------------------------&#xD;
//	FSM Output Logic&#xD;
//	-------------------------------------------------------------------------------------&#xD;
always @ (posedge clk) begin&#xD;
	if(current_state==S_IDLE) begin&#xD;
		reg1	&lt;= 1'b0;&#xD;
	end&#xD;
	else if(input_port1==1'b1) begin&#xD;
		reg1	&lt;= reg1 + 1'b1;&#xD;
	end&#xD;
end&#xD;
&#xD;
always @ (posedge clk) begin&#xD;
	if(current_state==S_1) begin&#xD;
		reg2	&lt;= 1'b0;&#xD;
	end&#xD;
	else if(current_state==S_2) begin&#xD;
		reg2	&lt;= reg2 + 1'b1;&#xD;
	end&#xD;
end</Template><Template Name="edge" Description="" Comments="0" Strings="0">//asynchronous clock domain&#xD;
reg		[2:0]		[+sig+]_shift	= 3'b000;&#xD;
wire				[+sig+]_rise	;&#xD;
wire				[+sig+]_fall	;&#xD;
always @ (posedge clk) begin&#xD;
	[+sig+]_shift	&lt;= {[+sig+]_shift[1:0],i_[+sig+]};&#xD;
end&#xD;
assign	[+sig+]_rise	= ([+sig+]_shift[2:1]==2'b01) ? 1'b1 : 1'b0;&#xD;
assign	[+sig+]_fall	= ([+sig+]_shift[2:1]==2'b10) ? 1'b1 : 1'b0;&#xD;
&#xD;
//synchronous clock domain&#xD;
reg					[+sig+]_dly	= 1'b0;&#xD;
wire				[+sig+]_rise	;&#xD;
wire				[+sig+]_fall	;&#xD;
always @ (posedge clk) begin&#xD;
	[+sig+]_dly	&lt;= i_[+sig+];&#xD;
end&#xD;
assign	[+sig+]_rise	= ([+sig+]_dly==1'b0 &amp;&amp; i_[+sig+]==1'b1) ? 1'b1 : 1'b0;&#xD;
assign	[+sig+]_fall	= ([+sig+]_dly==1'b1 &amp;&amp; i_[+sig+]==1'b0) ? 1'b1 : 1'b0;&#xD;
&#xD;
//just delay&#xD;
reg		[1:0]		[+sig+]_shift	= 2'b00;&#xD;
always @ (posedge clk) begin&#xD;
	[+sig+]_shift	&lt;= {[+sig+]_shift[0],i_[+sig+]};&#xD;
end</Template><Template Name="lfsr" Description="" Comments="0" Strings="0">reg		[[+n+]-1:0]	lfsr_shift 	= [+n+]'hab;&#xD;
wire			lfsr_seed	;&#xD;
&#xD;
always @ (posedge clk) begin&#xD;
	lfsr_shift	&lt;= {lfsr_shift[[+n+]-2:0],lfsr_seed};&#xD;
end&#xD;
assign	lfsr_seed	= lfsr_shift[1] ^^ lfsr_shift[2] ^^ lfsr_shift[4];</Template><Template Name="driver" Description="" Comments="0" Strings="0">//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x7248;&#x6743;&#x6240;&#x6709;&#x8005;   : &#x4E2D;&#x56FD;&#x5927;&#x6052;&#xFF08;&#x96C6;&#x56E2;&#xFF09;&#x6709;&#x9650;&#x516C;&#x53F8;&#x5317;&#x4EAC;&#x56FE;&#x50CF;&#x89C6;&#x89C9;&#x6280;&#x672F;&#x5206;&#x516C;&#x53F8;, 2010 -2015.&#xD;
//  -- &#x4FDD;&#x5BC6;&#x7EA7;&#x522B;     &#xFF1A;&#x7EDD;&#x5BC6;.&#xD;
//  -- &#x90E8;&#x95E8;         : &#x786C;&#x4EF6;&#x90E8;&#xFF0C;FPGA&#x5DE5;&#x4F5C;&#x7EC4;&#xD;
//  -- &#x6A21;&#x5757;&#x540D;       : driver_timestamp&#xD;
//  -- &#x8BBE;&#x8BA1;&#x8005;       : &#x90A2;&#x6D77;&#x6D9B;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x7248;&#x672C;&#x8BB0;&#x5F55; :&#xD;
//&#xD;
//  -- &#x4F5C;&#x8005;         :| &#x4FEE;&#x6539;&#x65E5;&#x671F;				:|  &#x4FEE;&#x6539;&#x8BF4;&#x660E;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//  -- &#x90A2;&#x6D77;&#x6D9B;       :| 2016/04/25 17:43:54	:|  &#x521D;&#x59CB;&#x7248;&#x672C;&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//&#xD;
//  -- &#x6A21;&#x5757;&#x63CF;&#x8FF0;     :&#xD;
//              1)  :&#xD;
//&#xD;
//              2)  :&#xD;
//&#xD;
//              3)  :&#xD;
//&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
//`include			"driver_timestamp_def.v"&#xD;
//&#x4EFF;&#x771F;&#x5355;&#x4F4D;/&#x7CBE;&#x5EA6;&#xD;
`timescale 1ns/1ps&#xD;
//-------------------------------------------------------------------------------------------------&#xD;
`define		TESTCASE	testcase_1&#xD;
&#xD;
module driver_timestamp ();&#xD;
&#xD;
	//	ref signals&#xD;
	//	===============================================================================================&#xD;
	//	--ref parameter&#xD;
	//	===============================================================================================&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x53C2;&#x6570;&#x5B9A;&#x4E49;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	parameter	CLK_PERIOD_NS		= `TESTCASE.CLK_PERIOD_NS			;&#xD;
	parameter	LONG_REG_WD			= `TESTCASE.LONG_REG_WD			;&#xD;
&#xD;
	//	===============================================================================================&#xD;
	//	--ref signal&#xD;
	//	===============================================================================================&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x8F93;&#x5165;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	wire									clk	;&#xD;
	wire									reset	;&#xD;
	wire									i_fval		;&#xD;
	wire									i_timestamp_load	;&#xD;
&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x8F93;&#x51FA;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	wire	[LONG_REG_WD-1:0]				ov_timestamp_u3	;&#xD;
	wire	[LONG_REG_WD-1:0]				ov_timestamp_reg	;&#xD;
&#xD;
&#xD;
	//	ref ARCHITECTURE&#xD;
&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x5F15;&#x7528;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	assign	clk					= `TESTCASE.timestamp_clk	;&#xD;
	assign	reset				= `TESTCASE.reset	;&#xD;
	assign	i_fval				= `TESTCASE.i_fval		;&#xD;
	assign	i_timestamp_load	= `TESTCASE.i_timestamp_load	;&#xD;
&#xD;
	//  -------------------------------------------------------------------------------------&#xD;
	//	&#x4F8B;&#x5316; timestamp&#xD;
	//  -------------------------------------------------------------------------------------&#xD;
	timestamp # (&#xD;
	.CLK_PERIOD_NS			(CLK_PERIOD_NS			),&#xD;
	.LONG_REG_WD			(LONG_REG_WD			)&#xD;
	)&#xD;
	timestamp_inst (&#xD;
	.clk					(clk					),&#xD;
	.reset					(reset					),&#xD;
	.i_fval					(i_fval					),&#xD;
	.ov_timestamp_u3		(ov_timestamp_u3		),&#xD;
	.i_timestamp_load		(i_timestamp_load		),&#xD;
	.ov_timestamp_reg		(ov_timestamp_reg		)&#xD;
	);&#xD;
&#xD;
&#xD;
&#xD;
endmodule</Template><Template Name="mono" Description="" Comments="0" Strings="0">	//	-------------------------------------------------------------------------------------&#xD;
	//	USB3 Vision 	version 1.0.1	March, 2015&#xD;
	//	table 5-14: Recommended Pixel Formats&#xD;
	//&#xD;
	//	Mono1p			0x01010037&#xD;
	//	Mono2p			0x01020038&#xD;
	//	Mono4p			0x01040039&#xD;
	//	Mono8			0x01080001&#xD;
	//	Mono10			0x01100003&#xD;
	//	Mono10p			0x010a0046&#xD;
	//	Mono12			0x01100005&#xD;
	//	Mono12p			0x010c0047&#xD;
	//	Mono14			0x01100025&#xD;
	//	Mono16			0x01100007&#xD;
	//&#xD;
	//	BayerGR8		0x01080008&#xD;
	//	BayerGR10		0x0110000C&#xD;
	//	BayerGR10p		0x010A0056&#xD;
	//	BayerGR12		0x01100010&#xD;
	//	BayerGR12p		0x010C0057&#xD;
	//	BayerGR16		0x0110002E&#xD;
	//&#xD;
	//	BayerRG8		0x01080009&#xD;
	//	BayerRG10		0x0110000D&#xD;
	//	BayerRG10p		0x010A0058&#xD;
	//	BayerRG12		0x01100011&#xD;
	//	BayerRG12p		0x010C0059&#xD;
	//	BayerRG16		0x0110002F&#xD;
	//&#xD;
	//	BayerGB8		0x0108000A&#xD;
	//	BayerGB10		0x0110000E&#xD;
	//	BayerGB10p		0x010A0054&#xD;
	//	BayerGB12		0x01100012&#xD;
	//	BayerGB12p		0x010C0055&#xD;
	//	BayerGB16		0x01100030&#xD;
	//&#xD;
	//	BayerBG8		0x0108000B&#xD;
	//	BayerBG10		0x0110000F&#xD;
	//	BayerBG10p		0x010A0052&#xD;
	//	BayerBG12		0x01100013&#xD;
	//	BayerBG12p		0x010C0053&#xD;
	//	BayerBG16		0x01100031&#xD;
&#xD;
	//	BGR8			0x02180015&#xD;
	//	BGR10			0x02300019&#xD;
	//	BGR10p			0x021E0048&#xD;
	//	BGR12			0x0230001B&#xD;
	//	BGR12p			0x02240049&#xD;
	//	BGR14			0x0230004A&#xD;
	//	BGR16			0x0230004B&#xD;
&#xD;
	//	BGRa8			0x02200017&#xD;
	//	BGRa10			0x0240004C&#xD;
	//	BGRa10p			0x0228004D&#xD;
	//	BGRa12			0x0240004E&#xD;
	//	BGRa12p			0x0230004F&#xD;
	//	BGRa14			0x02400050&#xD;
	//	BGRa16			0x02400051&#xD;
	//&#xD;
	//	YCbCr8			0x0218005B&#xD;
	//	YCbCr422_8		0x0210003B&#xD;
	//	YCbCr411_8		0x020C005A&#xD;
	//&#xD;
	//	--&#x5982;&#x679C;&#x8981;&#x5224;&#x65AD;&#x9ED1;&#x767D;&#x683C;&#x5F0F;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x5224;&#x65AD;&#x4F4E;7bit&#x5C31;&#x53EF;&#x4EE5;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x5224;&#x65AD;&#x989C;&#x8272;&#x683C;&#x5F0F;&#xD;
	//	--&#x6839;&#x636E;u3v&#x534F;&#x8BAE;&#xFF0C;&#x5224;&#x65AD;&#x51FA;&#x9ED1;&#x767D;&#x7684;&#x50CF;&#x7D20;&#x683C;&#x5F0F;&#xD;
	//	--&#x53EA;&#x9700;&#x8981;&#x5224;&#x65AD;&#x4F4E;7bit&#x5373;&#x53EF;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	always @ (posedge clk) begin&#xD;
		case(iv_pixel_format[6:0])&#xD;
			7'h37	: mono_sel	&lt;= 1'b1	;		//	Mono1p			0x01010037&#xD;
			7'h38	: mono_sel	&lt;= 1'b1	;		//	Mono2p			0x01020038&#xD;
			7'h39	: mono_sel	&lt;= 1'b1	;		//	Mono4p			0x01040039&#xD;
			7'h01	: mono_sel	&lt;= 1'b1	;		//	Mono8			0x01080001&#xD;
			7'h03	: mono_sel	&lt;= 1'b1	;		//	Mono10			0x01100003&#xD;
			7'h46	: mono_sel	&lt;= 1'b1	;		//	Mono10p			0x010a0046&#xD;
			7'h05	: mono_sel	&lt;= 1'b1	;		//	Mono12			0x01100005&#xD;
			7'h47	: mono_sel	&lt;= 1'b1	;		//	Mono12p			0x010c0047&#xD;
			7'h25	: mono_sel	&lt;= 1'b1	;		//	Mono14			0x01100025&#xD;
			7'h07	: mono_sel	&lt;= 1'b1	;		//	Mono16			0x01100007&#xD;
			default	: mono_sel	&lt;= 1'b0	;		//	others&#xD;
		endcase&#xD;
	end</Template><Template Name="format8" Description="" Comments="0" Strings="0">	//	-------------------------------------------------------------------------------------&#xD;
	//	USB3 Vision 	version 1.0.1	March, 2015&#xD;
	//	table 5-14: Recommended Pixel Formats&#xD;
	//&#xD;
	//	Mono1p			0x01010037&#xD;
	//	Mono2p			0x01020038&#xD;
	//	Mono4p			0x01040039&#xD;
	//	Mono8			0x01080001&#xD;
	//	Mono10			0x01100003&#xD;
	//	Mono10p			0x010a0046&#xD;
	//	Mono12			0x01100005&#xD;
	//	Mono12p			0x010c0047&#xD;
	//	Mono14			0x01100025&#xD;
	//	Mono16			0x01100007&#xD;
	//&#xD;
	//	BayerGR8		0x01080008&#xD;
	//	BayerGR10		0x0110000C&#xD;
	//	BayerGR10p		0x010A0056&#xD;
	//	BayerGR12		0x01100010&#xD;
	//	BayerGR12p		0x010C0057&#xD;
	//	BayerGR16		0x0110002E&#xD;
	//&#xD;
	//	BayerRG8		0x01080009&#xD;
	//	BayerRG10		0x0110000D&#xD;
	//	BayerRG10p		0x010A0058&#xD;
	//	BayerRG12		0x01100011&#xD;
	//	BayerRG12p		0x010C0059&#xD;
	//	BayerRG16		0x0110002F&#xD;
	//&#xD;
	//	BayerGB8		0x0108000A&#xD;
	//	BayerGB10		0x0110000E&#xD;
	//	BayerGB10p		0x010A0054&#xD;
	//	BayerGB12		0x01100012&#xD;
	//	BayerGB12p		0x010C0055&#xD;
	//	BayerGB16		0x01100030&#xD;
	//&#xD;
	//	BayerBG8		0x0108000B&#xD;
	//	BayerBG10		0x0110000F&#xD;
	//	BayerBG10p		0x010A0052&#xD;
	//	BayerBG12		0x01100013&#xD;
	//	BayerBG12p		0x010C0053&#xD;
	//	BayerBG16		0x01100031&#xD;
&#xD;
	//	BGR8			0x02180015&#xD;
	//	BGR10			0x02300019&#xD;
	//	BGR10p			0x021E0048&#xD;
	//	BGR12			0x0230001B&#xD;
	//	BGR12p			0x02240049&#xD;
	//	BGR14			0x0230004A&#xD;
	//	BGR16			0x0230004B&#xD;
&#xD;
	//	BGRa8			0x02200017&#xD;
	//	BGRa10			0x0240004C&#xD;
	//	BGRa10p			0x0228004D&#xD;
	//	BGRa12			0x0240004E&#xD;
	//	BGRa12p			0x0230004F&#xD;
	//	BGRa14			0x02400050&#xD;
	//	BGRa16			0x02400051&#xD;
	//&#xD;
	//	YCbCr8			0x0218005B&#xD;
	//	YCbCr422_8		0x0210003B&#xD;
	//	YCbCr411_8		0x020C005A&#xD;
	//	&#x5176;&#x4E2D; BGR8 BGRa8 YCbCr8 YCbCr422_8 YCbCr411_8 &#x4E0D;&#x662F;8bit&#x50CF;&#x7D20;&#x683C;&#x5F0F;&#xD;
	//  -------------------------------------------------------------------------------------&#xD;
	//	format8_sel&#xD;
	//	1.&#x5224;&#x65AD;&#x50CF;&#x7D20;&#x683C;&#x5F0F;&#x662F;&#x5426;&#x9009;&#x4E2D;8bit&#x50CF;&#x7D20;&#x683C;&#x5F0F;&#xD;
	//  -------------------------------------------------------------------------------------&#xD;
	always @ (posedge clk) begin&#xD;
		if(stream_enable_rise==1'b1) begin&#xD;
			case (iv_pixel_format[6:0])&#xD;
				7'h01		: format8_sel	&lt;= 1'b1;&#xD;
				7'h08		: format8_sel	&lt;= 1'b1;&#xD;
				7'h09		: format8_sel	&lt;= 1'b1;&#xD;
				7'h0A		: format8_sel	&lt;= 1'b1;&#xD;
				7'h0B		: format8_sel	&lt;= 1'b1;&#xD;
				default		: format8_sel	&lt;= 1'b0;&#xD;
			endcase&#xD;
		end&#xD;
	end</Template><Template Name="lane" Description="" Comments="0" Strings="0">genvar	i;&#xD;
generate&#xD;
	for(i=0;i&lt;CHANNEL_NUM;i=i+1) begin&#xD;
		assign	wv_data_lane[i]	= iv_pix_data[DATA_WIDTH*(i+1)-1:DATA_WIDTH*i];&#xD;
	end&#xD;
endgenerate&#xD;
&#xD;
genvar	i;&#xD;
generate&#xD;
	for(i=0;i&lt;CHANNEL_NUM;i=i+1) begin&#xD;
		assign	iv_pix_data[DATA_WIDTH*(i+1)-1:DATA_WIDTH*i]	= wv_data_lane[i];&#xD;
	end&#xD;
endgenerate</Template><Template Name="gray_code" Description="" Comments="0" Strings="0">parameter gray_width = &lt;gray_value_width&gt;;&#xD;
&#xD;
reg  [gray_width-1:0] &lt;binary_value&gt; = {{gray_width{1'b0}}, 1'b1};&#xD;
reg  [gray_width-1:0] &lt;gray_value&gt; = {gray_width{1'b0}};&#xD;
&#xD;
always @(posedge &lt;clock&gt;)&#xD;
if (&lt;reset&gt;) begin&#xD;
	&lt;binary_value&gt; &lt;= {{gray_width{1'b0}}, 1'b1};&#xD;
	&lt;gray_value&gt; &lt;= {gray_width{1'b0}};&#xD;
end&#xD;
else if (&lt;clock_enable&gt;) begin&#xD;
	&lt;binary_value&gt; &lt;= &lt;binary_value&gt; + 1;&#xD;
	&lt;gray_value&gt; &lt;= (&lt;binary_value&gt; &gt;&gt; 1) ^ &lt;binary_value&gt;;&#xD;
end</Template><Template Name="***&#x6210;&#x719F;&#x4EE3;&#x7801;&#x6BB5;-function***" Description="" Comments="0" Strings="0"/><Template Name="log2" Description="" Comments="0" Strings="0">//	-------------------------------------------------------------------------------------&#xD;
//	&#x53D6;&#x5BF9;&#x6570;&#xFF0C;&#x4E0A;&#x53D6;&#x6574;&#xD;
//	log2&#x53D6;&#x5BF9;&#x6570;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6709;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x3002;&#x5206;&#x522B;&#x662F;&#x8BA1;&#x7B97;&#x8BA1;&#x6570;&#x5668;&#x7684;&#x4F4D;&#x5BBD;&#x548C;&#x8BA1;&#x7B97;&#x901A;&#x9053;&#x504F;&#x79FB;&#x7684;bit&#x6570;&#xD;
//	1.&#x8BA1;&#x7B97;&#x8BA1;&#x6570;&#x5668;&#x7684;&#x4F4D;&#x5BBD;&#xFF0C;&#x4F7F;&#x7528; y = log2(x+1)&#xFF0C;&#x5F53;x=2^^n&#x65F6;&#xFF0C;y=n+1&#xFF0C;&#x53EF;&#x4EE5;&#x8868;&#x793A;0-2^^(n+1)-1&#x7684;&#x6570;&#x503C;&#xD;
//	2.&#x8BA1;&#x7B97;&#x901A;&#x9053;&#x504F;&#x79FB;&#x7684;bit&#x6570;&#xFF0C;&#x4F7F;&#x7528; y = log2(x)&#xFF0C;&#x5F53;x=2^^n&#x65F6;&#xFF0C;y=n&#xFF0C;&#x53EF;&#x4EE5;&#x8868;&#x793A;0-2^^n-1&#x7684;&#x6570;&#x503C;&#xD;
//	-------------------------------------------------------------------------------------&#xD;
function integer log2 (input integer xx);&#xD;
	integer x;&#xD;
	begin&#xD;
		x	= xx-1 ;&#xD;
		for (log2=0;x&gt;0;log2=log2+1) begin&#xD;
			x	= x &gt;&gt; 1;&#xD;
		end&#xD;
	end&#xD;
endfunction</Template><Template Name="cdiv" Description="" Comments="0" Strings="0">	//	-------------------------------------------------------------------------------------&#xD;
	//	&#x9664;&#x6CD5;&#x4E0A;&#x53D6;&#x6574;&#xD;
	//	-------------------------------------------------------------------------------------&#xD;
	function integer cdiv;&#xD;
		input integer	dividend;	//&#x88AB;&#x9664;&#x6570;&#xD;
		input integer	divisior;	//&#x9664;&#x6570;&#xD;
		integer			division;	//&#x5546;&#xD;
&#xD;
		begin&#xD;
			//&#x6B64;&#x5904;&#x7684;&#x9664;&#x6CD5;&#x662F;&#x4E0B;&#x53D6;&#x6574;&#xD;
			division	= dividend/divisior;&#xD;
			//&#x5982;&#x679C; &#x5546;*&#x9664;&#x6570;=&#x88AB;&#x9664;&#x6570; &#xFF0C;&#x5219;&#x662F;&#x6574;&#x9664;&#x3002;&#x5426;&#x5219;&#xFF0C;&#x5B58;&#x5728;&#x7701;&#x7565;&#x7684;&#x5C0F;&#x6570;&#x90E8;&#x5206;&#xFF0C;&#x5546;&#x8981;&#x52A0;1&#xD;
			cdiv		= (division*divisior==dividend) ? division : division+1;&#xD;
		end&#xD;
	endfunction</Template><Template Name="max" Description="" Comments="0" Strings="0">// -------------------------------------------------------------------------------------&#xD;
// max&#x53D6;&#x6700;&#x5927;&#x503C;&#xD;
// -------------------------------------------------------------------------------------&#xD;
&#xD;
function integer max(input integer n1, input integer n2);&#xD;
 max = (n1 &gt; n2) ? n1 : n2;&#xD;
endfunction</Template><Template Name="min" Description="" Comments="0" Strings="0">function integer min(input integer n1, input integer n2);&#xD;
	min = (n1 &lt; n2) ? n1 : n2;&#xD;
endfunction</Template><Template Name="cycle_acc_minus" Description="" Comments="0" Strings="0">// -------------------------------------------------------------------------------------&#xD;
// cycle_acc_minus &#x5FAA;&#x73AF;&#x7D2F;&#x52A0;&#x51FD;&#x6570;&#xFF0C;&#x7D2F;&#x52A0;&#x4E4B;&#x540E;&#x518D;&#x51CF;1&#xD;
// -------------------------------------------------------------------------------------&#xD;
function integer cycle_acc_minus;&#xD;
	input integer in_cnt;&#xD;
	integer i;&#xD;
&#xD;
	begin&#xD;
		cycle_acc_minus = 0 ;&#xD;
		for(i=0;i&lt;32;i=i+1) begin&#xD;
			cycle_acc_minus = cycle_acc_minus + in_cnt[i];&#xD;
		end&#xD;
		cycle_acc_minus = cycle_acc_minus - 1;&#xD;
	end&#xD;
endfunction</Template><Template Name="cycle_acc" Description="" Comments="0" Strings="0">// -------------------------------------------------------------------------------------&#xD;
// cycle_acc &#x5FAA;&#x73AF;&#x7D2F;&#x52A0;&#x51FD;&#x6570;&#xD;
// -------------------------------------------------------------------------------------&#xD;
function integer cycle_acc;&#xD;
	input integer in_cnt;&#xD;
	integer i;&#xD;
&#xD;
	begin&#xD;
		cycle_acc = 0 ;&#xD;
		for(i=0;i&lt;32;i=i+1) begin&#xD;
			cycle_acc = cycle_acc + in_cnt[i];&#xD;
		end&#xD;
	end&#xD;
endfunction</Template><Template Name="valid_bit_num" Description="" Comments="0" Strings="0">// -------------------------------------------------------------------------------------&#xD;
// &#x8BA1;&#x7B97;&#x4E00;&#x4E2A;2&#x8FDB;&#x5236;&#x7684;&#x6570;&#x636E;&#x4E2D;&#xFF0C;&#x503C;&#x4E3A;1'b1&#x7684;&#x4F4D;&#x7684;&#x4E2A;&#x6570;&#xD;
// -------------------------------------------------------------------------------------&#xD;
function [VALID_BIT_NUM_WD-1:0] valid_bit_num;&#xD;
	input [DATA_WIDTH-1:0] valid_bit_calc;&#xD;
	integer x;&#xD;
	begin&#xD;
		valid_bit_num = 0;&#xD;
		for (x=0;x&lt;GEV_DE_WD;x=x+1) begin&#xD;
			valid_bit_num = valid_bit_num + valid_bit_calc[x];&#xD;
		end&#xD;
	end&#xD;
endfunction</Template><Template Name="ptr_and_addr" Description="" Comments="0" Strings="0">// -------------------------------------------------------------------------------------&#xD;
// 2n &#x7B49;&#x5206;&#x5BFB;&#x5740;&#x7A7A;&#x95F4;&#x65F6;&#xFF0C;&#x6307;&#x9488;&#x4E0E;&#x5730;&#x5740;&#x7684;&#x52A8;&#x6001;&#x4F4D;&#x5BBD;&#x62FC;&#x63A5;&#xD;
// -------------------------------------------------------------------------------------&#xD;
// frame_depth             ptr_and_addr&#xD;
//&#xD;
// 0          |------------------------|&#xD;
// 1          ||-----------------------|&#xD;
// 2-3          | |----------------------|&#xD;
// 4-7          |  |---------------------|&#xD;
// 8-15         |   |--------------------|&#xD;
// 16-31         |    |-------------------|&#xD;
//&#xD;
//           |ptr |       addr        |&#xD;
// -------------------------------------------------------------------------------------&#xD;
// for &#x5FAA;&#x73AF;&#x5C55;&#x5F00;&#x4E4B;&#x540E;&#xD;
// &#x67E5;&#x770B;&#x7B49;&#x5206;&#x540E;&#x7684;&#x7A7A;&#x95F4;&#x4E2A;&#x6570;&#x843D;&#x5728;&#x54EA;&#x4E2A;&#x533A;&#x95F4;&#xFF0C;&#x9009;&#x62E9;&#x5BF9;&#x5E94;&#x7684;&#x6307;&#x9488;&#x548C;&#x5730;&#x5740;&#x7684;&#x62FC;&#x63A5;&#x65B9;&#x5F0F;&#xD;
//  -------------------------------------------------------------------------------------&#xD;
// PTR_WD &#x6700;&#x5927;&#x5E27;&#x6570;  &#x533A;&#x95F4;    byte_addr&#x5B9E;&#x9645;&#x6392;&#x5E03;&#xD;
// 1   1   0     {rd_addr[RD_ADDR_WD-1:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 1   2   1          {rd_ptr[0:0],rd_addr[RD_ADDR_WD-2:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 2   4   2-3     {rd_ptr[1:0],rd_addr[RD_ADDR_WD-3:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 3    8   4-7     {rd_ptr[2:0],rd_addr[RD_ADDR_WD-4:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 4   16   8-15    {rd_ptr[3:0],rd_addr[RD_ADDR_WD-5:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 5   32   16-31    {rd_ptr[4:0],rd_addr[RD_ADDR_WD-6:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 6   64   32-63    {rd_ptr[5:0],rd_addr[RD_ADDR_WD-7:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 7   128   64-127    {rd_ptr[6:0],rd_addr[RD_ADDR_WD-8:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// 8   256   128-255    {rd_ptr[7:0],rd_addr[RD_ADDR_WD-9:0],{(MCB_BYTE_NUM_WIDTH){1'b0}}}&#xD;
// ......&#xD;
// -------------------------------------------------------------------------------------&#xD;
function [RD_ADDR_WD-1:0] ptr_and_addr;&#xD;
	input [PTR_WD-1:0]   ptr_int;&#xD;
	input [RD_ADDR_WD-1:0]  addr_int;&#xD;
	input [PTR_WD-1:0]   depth_int;&#xD;
	integer i;&#xD;
	integer j;&#xD;
	begin&#xD;
		// -------------------------------------------------------------------------------------&#xD;
		// &#x5982;&#x679C;1&#x7B49;&#x5206;&#xFF0C;&#x76F4;&#x63A5;&#x628A;&#x5730;&#x5740;&#x8D4B;&#x503C;&#x7ED9;&#x8F93;&#x51FA;&#xD;
		// -------------------------------------------------------------------------------------&#xD;
		if(depth_int==0) begin&#xD;
			ptr_and_addr = addr_int;&#xD;
		end&#xD;
		// -------------------------------------------------------------------------------------&#xD;
		// &#x5982;&#x679C;n&#x7B49;&#x5206;&#xFF0C;&#x8981;&#x770B;&#x7B49;&#x5206;&#x4E2A;&#x6570;&#x843D;&#x5728;&#x54EA;&#x4E2A;&#x533A;&#x95F4;&#x5185;&#xD;
		// -------------------------------------------------------------------------------------&#xD;
		for(i=1;i&lt;=PTR_WD;i=i+1) begin&#xD;
			// -------------------------------------------------------------------------------------&#xD;
			// &#x6B64;&#x5904;&#x7684;&#x5224;&#x65AD;&#x6761;&#x4EF6;&#x662F;&#x68C0;&#x67E5;&#x7B49;&#x5206;&#x4E2A;&#x6570;&#x662F;&#x5426;&#x843D;&#x5728;&#x5BF9;&#x5E94;&#x7684;&#x533A;&#x95F4;&#x5185;&#xD;
			// &#x5728;&#x4E0D;&#x540C;&#x7684;&#x7B49;&#x5206;&#x4E2A;&#x6570;&#x533A;&#x95F4;&#x5185;&#xFF0C;&#x6307;&#x9488;&#x548C;&#x5730;&#x5740;&#x7684;&#x62FC;&#x63A5;&#x65B9;&#x5F0F;&#x662F;&#x4E0D;&#x4E00;&#x6837;&#x7684;&#xD;
			// -------------------------------------------------------------------------------------&#xD;
			if(depth_int&gt;=(2**(i-1)) &amp;&amp; depth_int&lt;=((2**i)-1)) begin&#xD;
				// -------------------------------------------------------------------------------------&#xD;
				// &#x5F53;&#x68C0;&#x6D4B;&#x5230;&#x7B49;&#x5206;&#x4E2A;&#x6570;&#x843D;&#x5728;&#x67D0;&#x4E00;&#x4E2A;&#x533A;&#x95F4;&#x4E4B;&#x540E;&#xFF0C;&#x5C31;&#x8981;&#x6309;&#x7167;&#x8FD9;&#x4E2A;&#x533A;&#x95F4;&#x7684;&#x6392;&#x5E03;&#x65B9;&#x5F0F;&#xFF0C;&#x5206;&#x914D;&#x6307;&#x9488;&#x548C;&#x5730;&#x5740;&#xD;
				// &#x7531;&#x4E8E;function&#x4E0D;&#x5141;&#x8BB8;&#x5730;&#x5740;&#x62FC;&#x63A5;&#x8FD0;&#x7B97;&#xFF0C;&#x6240;&#x4EE5;&#x53EA;&#x80FD;&#x6309;&#x4F4D;&#x8D4B;&#x503C;&#xD;
				// -------------------------------------------------------------------------------------&#xD;
				for(j=0;j&lt;RD_ADDR_WD;j=j+1) begin&#xD;
					// -------------------------------------------------------------------------------------&#xD;
					// &#x6839;&#x636E;&#x6620;&#x5C04;&#x89C4;&#x5F8B;&#xFF0C;&#x843D;&#x5728;i&#x533A;&#x95F4;&#x5185;&#xFF0C;&#x9AD8;i&#x4F4D;&#x662F;&#x6307;&#x9488;&#xFF0C;&#x5269;&#x4F59;&#x4F4E;&#x4F4D;&#x662F;&#x5730;&#x5740;&#xD;
					//&#xD;
					// ptr_and_addr : -|  ptr  |        addr         |-&#xD;
					//      i        RD_ADDR_WD-i&#xD;
					//&#xD;
					// -------------------------------------------------------------------------------------&#xD;
					if(j&lt;RD_ADDR_WD-i) begin&#xD;
						ptr_and_addr[j] = addr_int[j];&#xD;
					end&#xD;
					else begin&#xD;
						ptr_and_addr[j] = ptr_int[j-(RD_ADDR_WD-i)];&#xD;
					end&#xD;
				end&#xD;
			end&#xD;
		end&#xD;
	end&#xD;
endfunction</Template><Template Name="***&#x6210;&#x719F;&#x4EE3;&#x7801;&#x6BB5;-&#x6CE8;&#x91CA;***" Description="" Comments="0" Strings="0"/><Template Name="com" Description="" Comments="0" Strings="0">//	-------------------------------------------------------------------------------------&#xD;
//	^&#xD;
//	-------------------------------------------------------------------------------------</Template><Template Name="comd" Description="" Comments="0" Strings="0">//	===============================================================================================&#xD;
//	^&#xD;
//	===============================================================================================&#xD;
//	-------------------------------------------------------------------------------------&#xD;
//&#xD;
//	-------------------------------------------------------------------------------------</Template><Template Name="timing" Description="" Comments="0" Strings="0">	//	-------------------------------------------------------------------------------------&#xD;
	//&#xD;
	//	clk&#xD;
	//                        _________________________________________________&#xD;
	//	i_lval_delay         _|                                               |______________________&#xD;
	//                            _________________________________________________&#xD;
	//	lval_delay_dly0      _____|                                               |__________________&#xD;
	//                                _________________________________________________&#xD;
	//	lval_delay_dly1      _________|                                               |______________&#xD;
	//                                    _________________________________________________&#xD;
	//	lval_delay_dly2      _____________|                                               |__________&#xD;
	//                                        _________________________________________________&#xD;
	//	lval_delay_dly3      _________________|                                               |______&#xD;
	//                                            _________________________________________________&#xD;
	//	lval_delay_dly4      _____________________|                                               |__&#xD;
	//&#xD;
	//	mid line dly4        ---------------------|D0 |D1 |D2 |D3      -------------     |Dn-1|Dn |--&#xD;
	//&#xD;
	//	-------------------------------------------------------------------------------------</Template><Template Name="readmemh"/></Templates>
