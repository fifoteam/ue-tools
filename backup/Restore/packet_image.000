//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2018.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : packet_image
//  -- 设计者       : 张少强
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 版本号	:| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 张少强       :| V1.0		:| 2018/09/28 13:46:45	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     :
//              1)  :
//
//              2)  :
//
//              3)  :
//
//-------------------------------------------------------------------------------------------------
//`include			"packet_image_def.v"
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module packet_image # (
	parameter	GEV_DE_WD									= 2			,	//数据单元使能位宽，4byte数据使用一个使能位
	parameter	GEV_BE_WD									= 8			,	//字节使能位宽，1byte数据使用一个使能位
	parameter	GEV_DATA_WD									= 64		,	//数据位宽，支持32、64、128
	parameter	PKT_LENGTH_WD								= 13			//packet length 包长寄存器宽度
	)
	(
	input							clk_gev								,	//时钟信号
	input							reset_gev							,	//复位信号，clk时钟域;复位时所有的计数器、移位寄存器恢复初始值
	input							i_stream_enable						,	//clk_gev时钟域，流使能信号
	//	-------------------------------------------------------------------------------------
	//	寄存器信号
	//	-------------------------------------------------------------------------------------
	input  	[PKT_LENGTH_WD-1:0]		iv_pkt_length						,	//clk_gev时钟域，packet length 正常包包长,仅payload部分，不包括ip、udp、gvsp头
	//	-------------------------------------------------------------------------------------
	//	与frame_buffer交互
	//	-------------------------------------------------------------------------------------
	output							o_fb_rd								,	//clk_gev时钟域，帧存后端fifo读出使能信号，高有效
	input							i_fb_empty							,	//clk_gev时钟域，帧存后端fifo空信号，高有效
	input							i_fb_busy							,	//clk_gev时钟域，帧存后端busy信号，当为1时不能读
	input	[GEV_DE_WD-1:0]			iv_data_is_cmd						,	//clk_gev时钟域，帧存后端fifo输出数据是命令数据，单bit代表4byte，1-表示是命令数据，0-表示是图像数据
	input	[GEV_DE_WD-1:0]			iv_dval								,	//clk_gev时钟域，帧存后端fifo输出数据有效信号，单bit代表4byte，1-表示数据有效，0-表示数据无效
	input	[GEV_DATA_WD-1:0]		iv_data								,	//clk_gev时钟域，帧存后端fifo输出数据，支持32、64、128
	//	-------------------------------------------------------------------------------------
	//	与packet_comb交互
	//	-------------------------------------------------------------------------------------
	input							i_stop								,	//clk_gev时钟域， stop时本模块不能输出数据
	output	[GEV_DATA_WD-1:0]		ov_data								,	//clk_gev时钟域，输出图像数据
	output	[GEV_BE_WD-1:0]			ov_be								,	//clk_gev时钟域，输出字节有效，单bit代表1byte
	output							o_packet_over						,	//clk_gev时钟域，包结束
	//	-------------------------------------------------------------------------------------
	//	与gvsp_ctrl交互
	//	-------------------------------------------------------------------------------------
	input							i_start								,	//clk_gev时钟域，单bit信号触发本模块开始工作
	output							o_done								,	//clk_gev时钟域，单bit信号表示本模块工作完成
	output							o_again									//clk_gev时钟域，单bit信号表示本模块工作完成，需要重新启动一个新的包
	);
	//	===============================================================================================
	//	ref functions
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	计算位宽
	//	-------------------------------------------------------------------------------------
	function integer log2 (input integer xx);
		integer x;
		begin
			x	= xx-1 ;
			for (log2=0;x>0;log2=log2+1) begin
				x	= x >> 1;
			end
		end
	endfunction
	//	-------------------------------------------------------------------------------------
	//	计数be中1的个数
	//	-------------------------------------------------------------------------------------
	localparam		PTR_WD				= log2(GEV_BE_WD)+1	;	//
	function [PTR_WD:0]	be2cnt;
		input	[GEV_BE_WD-1:0]	be;
		integer	i;
		begin
			be2cnt = 0;
			for(i=0;i<GEV_BE_WD;i=i+1) begin
				be2cnt = be2cnt + be[i];
			end
		end
	endfunction

	//	===============================================================================================
	//	ref paramters
	//	===============================================================================================
	localparam		NORMAL_END			=	8'd1			;//正常帧结束命令
	localparam		RESEND_END			=	8'd3			;//重传帧结束命令
	localparam		STATIS_START		=	8'd6			;//STATIS段开始命令

	//	===============================================================================================
	//	ref signals
	//	===============================================================================================
	reg							rd_en			= 1'b0	;
	wire						output_data_valid	;//表示当前是否可以输出数据
	wire						input_data_valid	;//表示当前输入数据是否为有效数据
	wire [PKT_LENGTH_WD-1:0]	cnt					;
	reg	 [PKT_LENGTH_WD-1:0]	cnt_reg		= 'b0	;
	reg							cnt_up		= 'b0	;
	reg							first_ready = 'b0	;//
	//	===============================================================================================
	//	ref ARCHITECTURE
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	o_fb_rd
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk_gev) begin
		//时钟域复位或者停流时要复位
		if(reset_gev||~i_stream_enable) begin
			rd_en <= 1'b0;
		end
		//从i_start时开始读
		else if(i_start) begin
			rd_en <= 1'b1;
		end
		//直到o_done或again时停止
		else if(o_done || o_again) begin//请注意，使用again而不是o_again
			rd_en <= 1'b0;
		end
	end
	//	o_fb_rd:需要满足以下条件才可以为1
	//	3-1：当rd_en为1时且
	//	3-2：i_pb_empty为0
	//	3-2：i_stop为0
	//	3-3：first_ready为0（当first_ready为1时说明上次模块工作读出的多余数据尚未发出）
	assign o_fb_rd = rd_en && ~i_fb_empty && ~i_stop && ~first_ready;
	//	-------------------------------------------------------------------------------------
	//	-ref o_done
	//	在读出下一个命令时拉高o_done(注意使用i_start信号与当前命令区分开)
	//	-------------------------------------------------------------------------------------
	assign o_done = iv_dval[0] && iv_data_is_cmd[0] && o_fb_rd;
	//	-------------------------------------------------------------------------------------
	//	-ref o_again:
	//	当已经发出了一个包长的数据，又额外读出一组数据，发现这不是最后一个包，就发出1个clk的o_again提醒gvsp_ctrl_core模块重新启动一个新包。o_again为1的条件如下
	//	9-1：cnt_up为1
	//	9-2：iv_data为一组有效数据
	//	9-3: o_fb_rd为1
	//	-------------------------------------------------------------------------------------
	assign o_again = cnt_up && input_data_valid && o_fb_rd;
	//	input_data_valid表示输入数据是否至少有一组是有效数据，注意以下为按位操作符
	assign input_data_valid = |((~iv_data_is_cmd)&iv_dval);

	//	-------------------------------------------------------------------------------------
	//	-ref o_packet_over
	//	以下两种情况说明已经来到了包尾
	//	1、packet_image模块发出o_done信号且出现在端口上的新命令不是“正常帧结束”和“重传帧结束”命令和“STATIS开始”命令时说明是image包的包结束
	//	2、packet_image模块发出o_again时
	//	-------------------------------------------------------------------------------------
	assign o_packet_over = (o_done && iv_data[15:8]!=NORMAL_END && iv_data[15:8]!=RESEND_END && iv_data[15:8]!=STATIS_START)
							|| o_again;

	//	-------------------------------------------------------------------------------------
	//	-ref first_ready:
	//	当模块被启动时，如果帧存端口上有一组数据（而不是“IMAGE开始”命令）,那么这组数据将是这个包的第一组数据，在把这组数据发出前，不能从帧存中读新的数据。
	//	first_ready标志位指示这组数据是否存在且是否已经被发出
	//	10-1：当i_start为1且iv_data为一组有效数据时，first_ready为1
	//	10-2：当i_stop为0时，frist_ready为0，表示第一组数据已经被发出
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk_gev) begin
		if(reset_gev||~i_stream_enable) begin
			first_ready <= 1'b0;
		end
		else if(i_start) begin
			if(input_data_valid) begin
				first_ready <= 1'b1;
			end
			else begin
				first_ready <= 1'b0;
			end
		end
		else if(~i_stop) begin
			first_ready <= 1'b0;
		end
	end
	//	-------------------------------------------------------------------------------------
	//	-ref output_data_valid
	//	为1时指示输出数据有效
	//	一、如果模块开始工作时，端口上为一组数据，说明这是模块上一次工作时读出来但是没有传出去的数据，此时应该在i_stop为0时把这组数据传出去
	//		4-1：first_ready为1且i_stop为0时，o_valid为1
	//	二、需要把从帧存buffer中读出的数据传出去，但是超出一个包长后多读出的数据不能被传出（详见o_again）
	//		4-2：o_fb_rd为1且|iv_dval=1且
	//		4-3：o_done不为1（o_done为1时说明读出了一条命令）
	//		4-4：o_again不为1（o_again为1说明读出了超出正常包长度的数据，之所以读出这个数据的目的是表明这不是最后一个包，可以添加包尾标志）
	//	-------------------------------------------------------------------------------------
	assign output_data_valid = (first_ready && ~i_stop)
						||(o_fb_rd && |iv_dval && ~o_done && ~o_again);
	//	-------------------------------------------------------------------------------------
	//	-ref ov_be
	//	当output_data_valid为1时，如果iv_dval[0]=1则ov_be[3:0]=4’b1111，如果iv_dval[0]=0，说明ov_be[3:0]=4’b0000，iv_dval的其它位以此类推
	//	当output_data_valid为0时，ov_be为全0
	//	-------------------------------------------------------------------------------------
	genvar	i;
	generate
		for(i=0;i<GEV_DE_WD;i=i+1) begin
			assign ov_be[4*i+:4] = output_data_valid ? {4{iv_dval[i]}} : 0;
		end
	endgenerate
	//	-------------------------------------------------------------------------------------
	//	-ref ov_data
	//	当output_data_valid为1时，将ov_data=iv_data
	//	当output_data_valid为0时，ov_data为0
	//	-------------------------------------------------------------------------------------
	assign ov_data = output_data_valid ? iv_data : {GEV_DATA_WD{1'b0}};
	//	-------------------------------------------------------------------------------------
	//	cnt用于计数发出的有效字节数，当达到一个正常包长时就要结束本模块
	//	o_again或o_done为1时复位
	//	ov_be有几个1，cnt就累加几
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk_gev) begin
		if(reset_gev||~i_stream_enable) begin
			cnt_reg <= 'b0;
		end
		else if(o_again||o_done) begin
			cnt_reg <= 'b0;
		end
		else begin
			cnt_reg <= cnt;
		end
	end
	assign cnt = cnt_reg + be2cnt(ov_be);

//	当cnt计数到一个正常包长度的时候，就拉高cnt_up，cnt_up是一个中间信号，提醒本模块不能再发数据了
	always @ (posedge clk_gev) begin
		if(reset_gev||~i_stream_enable) begin
			cnt_up <= 1'b0;
		end
		else if(cnt >= iv_pkt_length)begin
			cnt_up <= 1'b1;
		end
		else begin
			cnt_up <= 1'b0;
		end
	end

endmodule
