//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : led_ctrl
//  -- 设计者       : 邢海涛
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 邢海涛       :| 2014/12/1 14:54:14	:|  初始版本
//  -- 邢海涛       :| 2016/6/8 13:47:56	:|  添加0x02，红灯闪烁的功能
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     : led 闪光灯控制模块
//              1)  : 根据寄存器设置情况，控制外部的LED灯状态
//
//              2)  : 外部有2个LED，红灯和绿灯，高电平点亮，两个灯都亮时，为黄色
//
//              3)  : ... ...
//
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module led_ctrl # (
	parameter		LED_CTRL_WIDTH			= 5			,	//LED CTRL 寄存器宽度
	parameter		LED_CLK_FREQ_KHZ		= 55000			//像素时钟频率，单位KHZ，很多模块用该时钟作为定时器，因此必须写明像素时钟的频率
	)
	(
	//时钟
	input								clk				,	//时钟信号
	//寄存器信号
	input								i_usb_slwr_n	,	//GPIF 写信号，clk_gpif时钟域
	//  -------------------------------------------------------------------------------------
	//	led_ctrl
	//	0x00:红灯常亮。此时FPGA程序未完成加载或在线升级中。
	//	0x01:无数据传输时，绿灯常亮；当图像数据传输时，绿灯闪烁，有图像数据时熄灭，无图像数据时点亮。
	//	0x10:黄灯闪烁(1Hz)。此时产生了一般错误，比如用户参数加载失败。
	//  -------------------------------------------------------------------------------------
	input	[LED_CTRL_WIDTH-1:0]		iv_led_ctrl		,	//led控制寄存器，FPGA外部连接红绿两个LED灯，两个LED同时亮时为黄色。
	//FPGA 引脚
	output								o_f_led_gre		,	//绿色指示灯，高电平点亮
	output								o_f_led_red			//红色指示灯，高电平点亮
	);

	//	ref signals
	localparam	TIME_INTERVAL_1SEC	= 1000*LED_CLK_FREQ_KHZ	;	//计数到 1SEC ，需要多少个时钟周期
	localparam	TIME_INTERVAL_50MS	= 50*LED_CLK_FREQ_KHZ	;	//计数到 50MS ，需要多少个时钟周期

	localparam	CNT_1SEC_WIDTH		= log2(TIME_INTERVAL_1SEC+1)	;	//计数器位宽
	localparam	CNT_50MS_WIDTH		= log2(TIME_INTERVAL_50MS+1)	;	//计数器位宽

	//	-------------------------------------------------------------------------------------
	//	取对数，上取整
	//	-------------------------------------------------------------------------------------
	function integer log2 (input integer xx);
		integer x;
		begin
			x	= xx-1 ;
			for (log2=0;x>0;log2=log2+1) begin
				x	= x >> 1;
			end
		end
	endfunction

	//	-------------------------------------------------------------------------------------
	//	出错，LED闪烁周期是1SEC
	//	-------------------------------------------------------------------------------------
	reg		[1:0]						usb_wr_shift	= 2'b0;
	reg		[LED_CTRL_WIDTH-1:0]		led_ctrl_reg	= 'b0;
	reg		[CNT_1SEC_WIDTH-1:0]		div_1hz_cnt		= 'b0;
	reg									twinkle_1hz		= 1'b0;
	reg									led_gre			= 1'b0;
	reg									led_red			= 1'b0;

	//	-------------------------------------------------------------------------------------
	//	传输阶段，LED闪烁周期是50ms
	//	-------------------------------------------------------------------------------------
	reg									twinkle_20hz_cnt_en			= 1'b0;
	reg		[CNT_50MS_WIDTH-1:0]		div_20hz_cnt				= 'b0;
	reg									twinkle_20hz				= 1'b0;


	//	ref ARCHITECTURE
	//	===============================================================================================
	//	ref ***led_ctrl***
	//	===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	跨时钟域同步
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		usb_wr_shift	<= {usb_wr_shift[0],i_usb_slwr_n};
	end

	//	-------------------------------------------------------------------------------------
	//	保护led_ctrl寄存器
	//	当设为非法值时，led_ctrl_reg不能更新
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(iv_led_ctrl[LED_CTRL_WIDTH-1:0])
			5'h00,5'h01,5'h02,5'h10	: begin
				led_ctrl_reg	<= iv_led_ctrl;
			end
			default	: begin
				led_ctrl_reg	<= led_ctrl_reg;
			end
		endcase
	end

	//  -------------------------------------------------------------------------------------
	//	1Hz信号
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(div_1hz_cnt==(TIME_INTERVAL_1SEC-1)) begin
			div_1hz_cnt	<= 'b0;
		end
		else begin
			div_1hz_cnt	<= div_1hz_cnt + 1'b1;
		end
	end

	always @ (posedge clk) begin
		if(div_1hz_cnt==(TIME_INTERVAL_1SEC-1)) begin
			twinkle_1hz	<= !twinkle_1hz;
		end
	end

	//  -------------------------------------------------------------------------------------
	//	绿灯
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(led_ctrl_reg[LED_CTRL_WIDTH-1:0])
			5'h00 	: led_gre	<= 1'b0;
			5'h01	: led_gre	<= twinkle_20hz;
			5'h02	: led_gre	<= 1'b0;
			5'h10	: led_gre	<= twinkle_1hz;
			default	: ;//概要设计没有明确说明处理方法，目前采取不理睬的处理方法
		endcase
	end
	assign	o_f_led_gre	= led_gre;

	//  -------------------------------------------------------------------------------------
	//	红灯
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		case(led_ctrl_reg[LED_CTRL_WIDTH-1:0])
			5'h00	: led_red	<= 1'b1;
			5'h01	: led_red	<= 1'b0;
			5'h02	: led_red	<= twinkle_1hz;
			5'h10	: led_red	<= twinkle_1hz;
			default	: ;//概要设计没有明确说明处理方法，目前采取不理睬的处理方法
		endcase
	end
	assign	o_f_led_red	= led_red;

	//	===============================================================================================
	//	ref ***传输阶段闪烁***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	计数器使能
	//	1.计数到50ms时，加法器使能取消
	//	2.当计数器没有计数到50ms时，只要写信号有效，计数器使能就有效
	//	3.一旦写信号有效，计数器使能就有效，一旦计数器加到最大值，计数器使能取消
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(div_20hz_cnt==(TIME_INTERVAL_50MS-1)) begin
			twinkle_20hz_cnt_en	<= 1'b0;
		end
		else if(!usb_wr_shift[1]) begin
			twinkle_20hz_cnt_en	<= 1'b1;
		end
	end

	//	-------------------------------------------------------------------------------------
	//	div_20hz_cnt 闪烁计数器
	//	1.计数器增加到50ms，返回0
	//	2.在计数器没有到达最大值时，只要计数器使能有效，就自增
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(div_20hz_cnt==(TIME_INTERVAL_50MS-1)) begin
			div_20hz_cnt	<= 'b0;
		end
		else if(twinkle_20hz_cnt_en) begin
			div_20hz_cnt	<= div_20hz_cnt + 1'b1;
		end
	end

	//	-------------------------------------------------------------------------------------
	//	闪烁信号
	//	1.当计数器是0时，闪烁信号为1，即点亮led
	//	2.当计数器增加到1/4周期时，熄灭led
	//	3.高电平时间只有1/4周期，led亮灯时间较短
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(div_20hz_cnt==0) begin
			twinkle_20hz	<= 1'b1;
		end
		else if(div_20hz_cnt==(TIME_INTERVAL_50MS/4)) begin
			twinkle_20hz	<= 1'b0;
		end
	end


endmodule
